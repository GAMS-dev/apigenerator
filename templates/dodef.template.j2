{%- extends "delphibase.template.j2" -%}

{%- set usecd = false -%}
{%- if apidef.UseCD.elements.shape[0] > 0 -%}
  {%- if apidef.UseCD.elements[apidef.UseCD.elements['prefix']==apidef.Prefix].shape[0] > 0 -%}
      {%- set usecd = true -%}
  {%- endif -%}
{%- endif -%}

{%- set USE_XXXLOADPATH = false -%}
{%- if apidef.ulp.elements.shape[0] > 0 -%}
   {%- if apidef.ulp.elements[apidef.ulp.elements['prefix']==apidef.Prefix].shape[0] > 0 -%}
      {%- set USE_XXXLOADPATH = true -%}
   {%- endif -%}
{%- endif -%}

{%- block header -%}
unit {{ apidef.DelphiObj }};
{ Delphi object wrapper {{ api.generatedstr }} }
{%  if apidef.dox == 'do'     -%}{ Object interface using a DLL }
{%- elif apidef.dox == 'dop'  -%}{ Object interface using a DLL, pure Delphi, static loading }
{%- elif apidef.dox == 'doco' -%}{ Object interface using a DLL, pure Delphi }
{%- elif apidef.dox == 'doex' -%}{ Object interface using the source directly (no DLL involved) }{% endif %}
{% endblock -%}

{%- block content -%}
{$P- no open parameters ==> no maxlen byte}
{$V+ force var strings}

{%- if apidef.DUnit.elements.shape[0] >0 -%}
    {%- set dunit = dunit(apidef.Prefix) -%}
{%- else                                 -%}
    {%- set dunit = '' -%}
{%- endif -%}
{%- set tpp        = datadef.tpp.elements['tp'].tolist() -%}
{%- set dobject    = dobject(apidef.Prefix)              -%}
{%- set dobjectint = dobjectint(apidef.Prefix)            %}

interface

uses
{%- if apidef.dox == 'do'     %}
   {$I p3compat},
   gmsgen
   {%- for key,value in apidef.ExtraUse.elements.iterrows() -%},
   {{ value['text'] }}
   {%- endfor -%};

{% elif apidef.dox == 'dop'  %}
   sysutils,
   gmsgen
   {%- for key,value in apidef.ExtraUse.elements.iterrows() -%},
   {{ value['text'] }}
   {%- endfor -%};

{% elif apidef.dox == 'docp' %}
   sysutils,
   gmsgen
   {%- for key,value in apidef.ExtraUse.elements.iterrows() -%},
   {{ value['text'] }}
   {%- endfor -%};

{% elif apidef.dox == 'doex' %}
   {$I p3compat},
   {{ dunit }},
   gmsgen
   {%- for key,value in apidef.ExtraUse.elements.iterrows() -%},
   {{ value['text'] }}
   {%- endfor -%};

{% endif -%}

{#- write constants -#}
{{ writeconst() }}

//tries to load DLL from OS default location
//name for the DLL is automatic
function  {{ apidef.Prefix }}GetReady(var Msg: ShortString): boolean;

//tries to load DLL from main program directory; if that fails
//loads DLL from OS default location
//name for the DLL is automatic
function  {{ apidef.Prefix }}GetReadyX(var Msg: ShortString): boolean;

//loads DLL from specified directory
//name for the DLL is automatic
function  {{ apidef.Prefix }}GetReadyD(const Dir: ShortString; var Msg: ShortString): boolean;

//loads DLL from the full path specified
//no changes are made to the name (platform and file extension)
function  {{ apidef.Prefix }}GetReadyL(const LibName: ShortString; var Msg: ShortString): boolean;

{%- if USE_XXXLOADPATH %}
procedure {{ apidef.Prefix }}SetLoadPath(const s: shortString);
procedure {{ apidef.Prefix }}GetLoadPath(var s: shortString);
{% endif %}

procedure {{ apidef.Prefix }}LibraryUnload;
function  {{ apidef.Prefix }}LibraryLoaded: boolean;

type
   TErrorCallback  = function(ErrCount:Integer; const Msg:ShortString):Integer; stdcall;

{%- if apidef.haveTypedefs %}
{%- for key,value in apidef.tPtrFunc.elements.iterrows() %}
   {%- if apidef.dox != 'doex' %}
   {{ value['name']}}  =
      {%- if value['type'] == 'void' %} procedure
      {%- else                       %} function
      {%- endif -%} (
      {%- set counter = namespace(argpos = 1) -%}
      {%- set ptrf    = apidef.PtrF.elements[apidef.PtrF.elements.name==value['name']] -%}
      {%- set ptrftpp = ptrf[ptrf['apos'].isin(tpp)]                                   -%}
      {%- for fkey,fvalue in ptrftpp.iterrows() %}
         {%- if apidef.dox == 'do'              -%} {{ DCall(fvalue['type']) }}
         {%- elif apidef.dox in ['dop', 'docp'] -%} {{ DPureCall(fvalue['type']) }}
         {%- endif -%}
         {%- if fvalue['type'] == 'bool'%}{{ fvalue['arg'] }}: Integer
         {%- else                       %}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
         {%- endif -%}
         {%- if counter.argpos < ptrftpp.shape[0] -%}; {% endif -%}
         {%- set counter.argpos = counter.argpos + 1 -%}
      {%- endfor -%}
      )
      {%- if value['type'] == 'void' -%} ;
      {%- else                       -%} : {{ DType(value['type']) }};
      {%- endif %} stdcall;
   {%- endif %}
   P{{ value['name'] }} = ^{{ value['name'] }};
{%- endfor %}
{%- endif %}

   {{ dobject }} = Class
   private
{%- if apidef.dox == 'doex' %}
      p{{ apidef.Prefix }}  : {{ dunit }}.{{ dobjectint }};
{%- else %}
      p{{ apidef.Prefix }}  : pointer;
{%- endif %}
      own   : boolean;

{%- for key,value in apidef.pn.elements.iterrows() %}
  {%- if value['pactions'] == 'r' %}
     {%- if value['type'] != 'funcptr' %}
      function  D{{ value['name'] }}: {{ DType(value['type']) }};
     {%- else %}
        {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] %}
        {% for fkey,fvalue in funcmap[funcmap['fpos']=='p'].iterrows() %}
      function  D{{ fvalue['def'] }}: P{{ fvalue['name']}};
        {% endfor %}
     {%- endif %}
  {%- else %}
     {%- if value['ta'] != 'funcptr' %}
      procedure D{{ value['name'] }}Set (const x: {{ DType(value['type']) }});
     {%- else %}
        {% set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] %}
        {% for fkey,fvalue in funcmap[funcmap['fpos']=='p'].iterrows() %}
      procedure D{{ fvalue['def'] }}Set (const x: P{{ fvalue['name']}});
        {%- endfor %}
   {%- endif %}
  {%- endif %}
{%- endfor %}

   public
      constructor Create          (var Msg: ShortString);
      constructor CreateX         (var Msg: ShortString);
      constructor CreateD         (const Dir: ShortString; var Msg: ShortString);
{%- if usecd %}
      constructor CreateDD        (const Dir: ShortString; var Msg: ShortString);
{%- endif %}
      constructor CreateL         (const LibName: ShortString; var Msg: ShortString);
{%- if apidef.dox == 'doex' %}
      constructor CreateWithHandle(p: {{ dunit }}.{{ dobjectint }}; var Msg: ShortString);
{%- else %}
      constructor CreateWithHandle(p: pointer; var Msg: ShortString);
{%- endif %}
      destructor  Destroy         ; override; { always use free and never destroy }
{% if apidef.dox == 'doex' %}
      function  {{ apidef.Prefix }}GetHandle            : {{ dunit }}.{{ dobjectint }};
{%- else %}
      function  {{ apidef.Prefix }}GetHandle            : pointer;
{%- endif %}
      function  {{ apidef.Prefix }}GetScreenIndicator   : boolean;
      procedure {{ apidef.Prefix }}SetScreenIndicator   (const ScrInd: boolean);
      function  {{ apidef.Prefix }}GetExceptionIndicator: boolean;
      procedure {{ apidef.Prefix }}SetExceptionIndicator(const ExcInd: boolean);
      function  {{ apidef.Prefix }}GetExitIndicator     : boolean;
      procedure {{ apidef.Prefix }}SetExitIndicator     (const ExtInd: boolean);
      function  {{ apidef.Prefix }}GetErrorCallback     : TErrorCallback;
      procedure {{ apidef.Prefix }}SetErrorCallback     (ecb: TErrorCallback);
      function  {{ apidef.Prefix }}GetErrorCount        : Integer;
      procedure {{ apidef.Prefix }}SetErrorCount        (const ecnt: Integer);

{%- set tpp   = datadef.tpp.elements['tp'].tolist() %}
{# write function -#}
{%- for key,value in apidef.tfunc.elements.iterrows() -%}
  {%- set fe = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
  {%- set len = apidef['idlenF']['value'] - fe['len'].iloc[0]              -%}
  {%- if value['type'] == 'void' %}
      procedure {{ value['name'] }}{{ prettyWhiteSpace(len) }}
  {%- else %}
      function  {{ value['name'] }}{{ prettyWhiteSpace(len) }}
  {%- endif %}
  {%- set arg = apidef.farg.elements[apidef.farg.elements['name']==value['name']] -%}
  {%- if arg.shape[0] > 0 -%}
     ( {%- set counter = namespace(argpos=1) -%}
       {%- set fe = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
       {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() -%}
         {%- if counter.argpos > 1 %} {% endif -%}
         {%- if fvalue['type'] != 'funcptr' -%}
            {{ DCall(fvalue['type']) }}{{ fvalue['arg']}}: {{ DType(fvalue['type']) }}
         {%- else                           -%}
            {%-if apidef.FuncMap.elements.shape[0] > 0 -%}
               {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
                {%- for fmkey,fmvalue in funcmap[funcmap['fpos']==fvalue['pos']].iterrows() if funcmap.shape[0] > 0 -%}
                  {{ DCall(fvalue['type']) }}{{fvalue['arg']}}: {{ fmvalue['name'] }}
               {%- endfor -%}
            {%- endif -%}
         {%- endif -%}
         {%- if arg.shape[0] > 0 -%} {%- if counter.argpos < arg['value'].iloc[0] -%} ; {%- endif -%}
         {%- set counter.argpos = counter.argpos + 1 -%}
         {%- endif -%}
       {%- endfor -%}
     )
  {%- endif -%}
  {%- if value['type'] == 'void' -%}
      ;
  {%- elif value['type'] == 'funcptr' -%}
      {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- for fmkey,fmvalue in funcmap.iterrows() -%}
          : {{ fmvalue['name'] }};
      {%- endfor -%}
  {%- else                            -%}
      : {{ DType(value['type']) }};
  {%- endif %}
{%- endfor %}
{%- if apidef.pn.elements.shape[0] > 0 %}

 { recovered properties }
{%- endif %}
{%- for key,value in apidef.tprop.elements.iterrows() -%}
   {%- set len = apidef['idlenP']['value'] - value['len']                                               -%}
   {%- if value['ta'] != 'funcptr'  %}
      property {{ value['name'] }}{{ prettyWhiteSpace(len) }}: {{ DType(value['type']) }}
   {%- else                        -%}
      {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- for fmkey,fmvalue in funcmap[funcmap['fpos']=='p'].iterrows() %}
      property {{ fmvalue['name'] }}{{ prettyWhiteSpace(len) }} : P{{ fmvalue['name'] }}
      {%- endfor %}
   {%- endif %}
   {%- set pn = apidef.pn.elements[apidef.pn.elements['name']==value['name']] -%}
   {%- for fkey,fvalue in pn[pn['type']==value['type']].iterrows() -%}
     {%- if fvalue['pactions'] == 'r' %} {{ pactions(fvalue['pactions']) }} D{{ fvalue['name'] }}
     {%- else                         %} {{ pactions(fvalue['pactions']) }} D{{ fvalue['name'] }}Set
     {%- endif -%}
  {%- endfor -%}
;
{%- endfor %}
   end;

implementation
{%- if apidef.dox != 'doex' %}
uses
   {{ apidef.DelphiCall }};

{%- endif %}

function {{ apidef.Prefix }}GetReady(var Msg: ShortString): boolean;
begin
{% if apidef.dox == 'doex' -%}
Msg := '';
Result := true
{% else -%}
Result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetReady(Msg);
{% endif -%}
end;

function  {{ apidef.Prefix }}GetReadyX(var Msg: ShortString): boolean;
begin
{% if apidef.dox == 'doex' -%}
Msg := '';
Result := true
{% else -%}
Result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetReadyX(Msg);
{% endif -%}
end;

function  {{ apidef.Prefix }}GetReadyD(const Dir: ShortString; var Msg: ShortString): boolean;
begin
{% if apidef.dox == 'doex' -%}
Msg := '';
Result := true
{% else -%}
Result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetReadyD(Dir,Msg);
{% endif -%}
end;

function  {{ apidef.Prefix }}GetReadyL(const LibName: ShortString; var Msg: ShortString): boolean;
begin
{% if apidef.dox == 'doex' -%}
Msg := '';
Result := true
{% else -%}
Result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetReadyL(LibName,Msg);
{% endif -%}
end;

{%- if USE_XXXLOADPATH  %}

procedure {{ apidef.Prefix }}SetLoadPath(const s: shortString);
begin
{%- if apidef.dox != 'doex' %}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}SetLoadPath(s);
{%- endif %}
end;

procedure {{ apidef.Prefix }}GetLoadPath(var s: shortString);
begin
{%- if apidef.dox != 'doex' %}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetLoadPath(s);
{%- endif %}
end;
{%- endif %}

procedure {{ apidef.Prefix }}LibraryUnload;
begin
{% if apidef.dox == 'do' -%}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}LibraryUnload;
{% elif apidef.dox == 'docp' -%}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}LibraryUnload;
{% endif -%}
end;

function  {{ apidef.Prefix }}LibraryLoaded: boolean;
begin
{% if apidef.dox == 'do'     -%} Result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}LibraryLoaded;
{% elif apidef.dox == 'docp' -%} Result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}LibraryLoaded;
{% elif apidef.dox == 'dop'  -%} Result := True;
{% elif apidef.dox == 'doex' -%} Result := True;
{% endif -%}
end;

constructor {{ dobject }}.Create(var Msg: ShortString);
begin
inherited Create;
own := true;
{% if apidef.dox != 'doex' -%}
if not {{ apidef.DelphiCall }}.{{ apidef.Prefix }}Create(p{{ apidef.Prefix }}, Msg) then begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then
      Msg := 'Unknown error calling {{ dobject }}.Create';
   end
else Msg := '';
{% else -%}
p{{ apidef.Prefix }} := {{ dunit }}.{{ dobjectint }}.Create(Msg);
{% endif -%}
end; (* {{ dobject }}.Create *)

constructor {{ dobject }}.CreateX(var Msg: ShortString);
{% if apidef.dox != 'doex' -%}
begin
inherited Create;
own := true;
if not {{ apidef.DelphiCall }}.{{ apidef.Prefix }}CreateX(p{{ apidef.Prefix }}, Msg) then begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then
      Msg := 'Unknown error calling {{ dobject }}.CreateX';
   end
else Msg := '';
{% else -%}
begin
Create(Msg);
{% endif -%}
end; (* {{ dobject }}.CreateX *)

constructor {{ dobject }}.CreateD(const Dir: ShortString; var Msg: ShortString);
{% if apidef.dox != 'doex' -%}
begin
inherited Create;
own := true;
if not {{ apidef.DelphiCall }}.{{ apidef.Prefix }}CreateD(p{{ apidef.Prefix }}, Dir, Msg) then begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then
      Msg := 'Unknown error calling {{ dobject }}.CreateD';
   end
 else Msg := '';
{% else -%}
begin
Create(Msg);
{% endif -%}
end; (* {{ dobject }}.CreateD *)

{% if ((apidef.dox != 'doex') and (usecd)) %}
constructor {{ dobject }}.CreateDD(const Dir: ShortString; var Msg: ShortString);
begin
inherited Create;
own := true;
if not {{ apidef.DelphiCall }}.{{ apidef.Prefix }}CreateDD(p{{ apidef.Prefix }}, Dir, Msg) then begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then
      Msg := 'Unknown error calling {{ dobject }}.CreateDD';
   end
 else Msg := '';
end; (* {{ dobject }}.CreateDD *)
{% endif -%}

{% if ((apidef.dox == 'doex') and (usecd)) %}
constructor {{ dobject }}.CreateDD(const Dir: ShortString; var Msg: ShortString);
begin
Create(Msg);
end; (* {{ dobject }}.CreateDD *)
{% endif %}

constructor {{ dobject }}.CreateL(const LibName: ShortString; var Msg: ShortString);
{%- if apidef.dox != 'doex' %}
begin
inherited Create;
own := true;
if not {{ apidef.DelphiCall }}.{{ apidef.Prefix }}CreateL(p{{ apidef.Prefix }}, LibName, Msg) then begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then
      Msg := 'Unknown error calling {{ dobject }}.CreateL';
   end
else Msg := '';
{%- else                    %}
begin
Create(Msg);
{%- endif %}
end; (* {{ dobject }}.CreateL *)

{% if apidef.dox != 'doex' -%}
constructor {{ dobject }}.CreateWithHandle(p: pointer; var Msg: ShortString);
begin
inherited Create;
own := false;
p{{ apidef.Prefix }} := p;
if not {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetReady(Msg) then begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then
      Msg := 'Unknown error calling {{ dobject }}.CreateWithHandle';
   end
else Msg := '';
{%- else %}
constructor {{ dobject }}.CreateWithHandle(p: {{ dunit }}.{{ dobjectint }}; var Msg: ShortString);
begin
inherited Create;
own := false;
p{{ apidef.Prefix }} := p;
Msg := '';
{%- endif %}
end; (* {{ dobject }}.CreateWithHandle *)

destructor {{ dobject }}.Destroy;
begin
if own
then
{% if apidef.dox != 'doex' %}   {{ apidef.DelphiCall }}.{{ apidef.Prefix }}Free(p{{ apidef.Prefix }});
{% else %}   p{{ apidef.Prefix }}.Free;
{% endif -%}
inherited destroy;
end;

{% if apidef.dox == 'doex' -%}function {{ dobject }}.{{ apidef.Prefix }}GetHandle: {{ dunit }}.{{ dobjectint }};
{% else -%} function {{ dobject }}.{{ apidef.Prefix }}GetHandle: pointer;
{%- endif %}
begin
Result := p{{ apidef.Prefix }};
end;

function  {{ dobject }}.{{ apidef.Prefix }}GetScreenIndicator: Boolean;
begin
{% if apidef.dox == 'do'     -%} result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetScreenIndicator;
{% elif apidef.dox == 'docp' -%} result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetScreenIndicator;
{% elif apidef.dox == 'dop'  -%} result := False;
{% elif apidef.dox == 'doex' -%} result := False;
{% endif -%}
end;

procedure {{ dobject }}.{{ apidef.Prefix }}SetScreenIndicator(const ScrInd: Boolean);
begin
{% if apidef.dox in ['do', 'docp'] -%}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}SetScreenIndicator(ScrInd);
{% endif -%}
end;

function  {{ dobject }}.{{ apidef.Prefix }}GetExceptionIndicator: Boolean;
begin
{% if apidef.dox in ['do', 'docp'] -%}
result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetExceptionIndicator;
{% elif apidef.dox in ['dop', 'doex'] -%}
result := False;
{% endif -%}
end;

procedure {{ dobject }}.{{ apidef.Prefix }}SetExceptionIndicator(const ExcInd: Boolean);
begin
{% if apidef.dox in ['do', 'docp'] -%}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}SetExceptionIndicator(ExcInd);
{% endif -%}
end;

function  {{ dobject }}.{{ apidef.Prefix }}GetExitIndicator: Boolean;
begin
{% if apidef.dox in ['do', 'docp'] -%}
result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetExitIndicator;
{% elif apidef.dox in ['dop', 'doex'] -%}
result := False;
{% endif -%}
end;

procedure {{ dobject }}.{{ apidef.Prefix }}SetExitIndicator(const ExtInd: Boolean);
begin
{% if apidef.dox in ['do', 'docp'] -%}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}SetExitIndicator(ExtInd);
{% endif -%}
end;

function  {{ dobject }}.{{ apidef.Prefix }}GetErrorCount: Integer;
begin
{% if apidef.dox in ['do', 'docp'] -%}
result := {{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetErrorCount;
{% elif apidef.dox in ['dop', 'doex'] -%}
result := 0;
{% endif -%}
end;

procedure {{ dobject }}.{{ apidef.Prefix }}SetErrorCount(const ecnt: Integer);
begin
{% if apidef.dox in ['do', 'docp'] -%}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}SetErrorCount(ecnt);
{% endif -%}
end;

function  {{ dobject }}.{{ apidef.Prefix }}GetErrorCallback: TErrorCallBack;
begin
{% if apidef.dox in ['do', 'docp'] -%}
result := TErrorCallBack({{ apidef.DelphiCall }}.{{ apidef.Prefix }}GetErrorCallback());
{% elif apidef.dox in ['dop', 'doex'] -%}
result := nil;
{% endif -%}
end;

procedure {{ dobject }}.{{ apidef.Prefix }}SetErrorCallback(ecb: TErrorCallBack);
begin
{%- if apidef.dox in ['do', 'docp'] %}
{{ apidef.DelphiCall }}.{{ apidef.Prefix }}SetErrorCallback(ecb);
{%- endif %}
end;

{% for key,value in apidef.pn.elements.iterrows() -%}
  {{ functionsDescription(value['text']) }}
   {%- if value['pactions'] == 'r' -%}
      {%- if value['type'] != 'funcptr' %}
function  {{ dobject }}.D{{ value['name'] }}: {{ DType(value['type']) }};
         {%- if apidef.dox != 'doex' %}
begin
result := {{ apidef.DelphiCall }}.{{ value['name'] }}(p{{ apidef.Prefix }});
         {%- else                    %}
begin
result := p{{ apidef.Prefix }}.{{ value['name'] }};
         {%- endif  %}
      {%- else                         %}
         {% for fmkey,fmvalue in apidef.FuncMap.elements[apidef.FuncMap.elements.name==value['name']].iterrows() %}
function  {{ dobject }}.D{{ value['name'] }}: P{{ fmvalue['en'] }};
            {%- if apidef.dox != 'doex'   %}
begin
result := P{{ fmvalue['en'] }}({{ apidef.DelphiCall }}.{{ value['name'] }}(p{{ apidef.Prefix }}));
            {%- else %}
begin
result := P{{ fmvalue['en'] }}(p{{ apidef.Prefix }}.{{ value['name'] }});
            {%- endif -%}
         {%- endfor %}
      {%- endif %}
end;
   {%- else                        -%}
      {%- if value['type'] != 'funcptr' %}
procedure {{ dobject }}.D{{ value['name'] }}Set(const x: {{ DType(value['type']) }});
         {%- if apidef.dox != 'doex' %}
begin
{{ apidef.DelphiCall }}.{{ value['name'] }}Set(p{{ apidef.Prefix }},x);
         {%- else                       %}
begin
p{{ apidef.Prefix }}.{{ value['name'] }} := x;
         {%- endif  %}
      {%- else %}
         {% for fmkey,fmvalue in apidef.FuncMap.elements[apidef.FuncMap.elements.name==value['name']].iterrows() -%}
procedure {{ dobject }}.D{{ value['name'] }}Set(const x: P{{ fmvalue['en'] }});
            {%- if apidef.dox != 'doex'   %}
begin
{{ apidef.DelphiCall }}.{{ value['name'] }}Set(p{{ apidef.Prefix }},{{ fmvalue['en'] }}(x));
            {%- else %}
begin
p{{ apidef.Prefix }}.{{ value['name'] }} := {{ fmvalue['name'] }}(x);
            {%- endif -%}
         {%- endfor %}
     {%- endif %}
end;
   {%- endif %}

{% endfor -%}

{% for key,value in apidef.tfunc.elements.iterrows() -%}
  {{ functionsDescription(value['text']) }}
  {%- if value['type'] == 'void' %}
procedure
  {%- else                       %}
function
  {%- endif %} {{ dobject }}.{{ value['name'] }}
  {%- set arg = apidef.farg.elements[apidef.farg.elements['name']==value['name']] -%}
  {%- if arg.shape[0] > 0 -%}
     ( {%- set counter = namespace(argpos = 1) -%}
       {%- set fe = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
       {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() -%}
         {%- if fvalue['type'] != 'funcptr' -%}
            {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
         {%- else                           -%}
            {%-if apidef.FuncMap.elements.shape[0] > 0 -%}
               {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
               {%- for fmkey,fmvalue in funcmap[funcmap['fpos']==fvalue['pos']].iterrows() if funcmap.shape[0] > 0 -%}
                  {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
               {%- endfor -%}
            {%- endif -%}
         {%- endif -%}
         {%- if counter.argpos < arg.iloc[0][1] -%}; {% endif -%}
         {%- set counter.argpos = counter.argpos + 1 -%}
       {%- endfor -%}
     )
  {%- endif -%}
  {%- if value['type'] == 'void'     -%}
      ;
begin
{# -#}
  {%- elif value['type'] == 'funcptr' -%}
      {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- for fmkey,fmvalue in funcmap.iterrows() -%}
         : {{ fmvalue['name'] }};
begin
result := {# -#}
      {%- endfor -%}
  {%- else                           -%}
      : {{ DType(value['type']) }};
begin
result := {# -#}
  {%- endif -%}
  {%- if (apidef.dox != 'doex') -%} {{ apidef.DelphiCall }}.{{ value['name'] }}(p{{ apidef.Prefix }}
      {%- set counter = namespace(pos = 1) -%}
      {%- if arg.shape[0] > 0 -%}
         {%- set fe = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
         {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() if fe.shape[0] > 0 -%}
, {{ fvalue['arg'] }}
            {%- set counter.pos = counter.pos + 1 -%}
         {%- endfor -%}
      {%- endif -%}
  {%- else                      -%} p{{ apidef.Prefix }}.{{ value['name'] }}(
      {%- set counter = namespace(pos = 1) -%}
      {%- if arg.shape[0] > 0 -%}
         {%- set fe = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
         {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() if fe.shape[0] > 0 -%}
{{ fvalue['arg'] }}
            {%- if counter.pos < arg.iloc[0][1] -%}, {% endif -%}
            {%- set counter.pos = counter.pos + 1 -%}
         {%- endfor -%}
      {%- endif -%}
  {%- endif -%}
);
{#- 
*LW Need to think about better schemem for automated error/exeception handling, bool=false does not have to be an error
*   if(sameas(ta,'bool'),
*      put$((dox=do) or (dox=docp)) / 'if Result = 0' / "then %DelphiCall%.%prefix%ErrorHandling('Problems when calling " en.tl ".');"
*   elseif sameas(ta,'rbool'),
*      put$((dox=do) or (dox=docp)) / 'if Result = 1' / "then %DelphiCall%.%prefix%ErrorHandling('Problems when calling " en.tl ".');"
#}
end;
{% endfor %}
end.
{% endblock -%}
