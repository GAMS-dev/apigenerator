{%- extends "delphibase.template.j2" -%}

{%- block header -%}
unit {{ apidef.DelphiCall }};
{ Delphi procedure wrapper {{ api.generatedstr }} }
{% if apidef.dcx == 'dc'     -%}{ Function interface using a DLL }
{% elif apidef.dcx == 'dp'   -%}{ Function interface using a DLL, pure Delphi, static loading }
{% elif apidef.dcx == 'dcp'  -%}{ Function interface using a DLL, pure Delphi }
{% elif apidef.dcx == 'dcex' -%}{ Function interface using the source directly (no DLL involved) }
{% endif -%}
{% endblock -%}

{%- block content -%}
{$P- no open parameters ==> no maxlen byte}
{$V+ force var strings}

{%- set generic = false -%}
{%- if apidef.generic.elements.shape[0] > 0 -%}
  {%- if apidef.generic.elements[apidef.generic.elements['prefix']==apidef.Prefix].shape[0] > 0 -%}
      {%- set generic = true -%}
  {%- endif -%}
{%- endif -%}
{%- set clibuse = false -%}
{%- if apidef.CLibUse.elements.shape[0] > 0 -%}
  {%- if apidef.CLibUse.elements[apidef.CLibUse.elements['prefix']==apidef.Prefix].shape[0] > 0 -%}
      {%- set clibuse = true -%}
  {%- endif -%}
{%- endif -%}
{%- set usecd = false -%}
{%- if apidef.UseCD.elements.shape[0] > 0 -%}
  {%- if apidef.UseCD.elements[apidef.UseCD.elements['prefix']==apidef.Prefix].shape[0] > 0 -%}
      {%- set usecd = true -%}
  {%- endif -%}
{%- endif -%}
{%- set havetypedefs = false -%}
{%- if apidef.haveTypedefs.elements.shape[0] > 0 -%}
  {%- if apidef.haveTypedefs.elements[apidef.haveTypedefs.elements['prefix']==apidef.Prefix].shape[0] > 0 -%}
      {%- set havetypedefs = true -%}
  {%- endif -%}
{%- endif -%}
{%- set USE_XXXLOADPATH = false -%}
{%- if apidef.ulp.elements.shape[0] > 0 -%}
   {%- if apidef.ulp.elements[apidef.ulp.elements['prefix']==apidef.Prefix].shape[0] > 0 -%}
      {%- set USE_XXXLOADPATH = true -%}
   {%- endif -%}
{%- endif -%}
{%- set dunit  = '' -%}
{%- if apidef.DUnit.elements.shape[0] > 0 -%}
    {%- set dunit  = apidef.DUnit.elements[apidef.DUnit.elements['prefix']==apidef.Prefix]['text'].iloc[0]           -%}
{%- endif -%}
{%- set dobjectint = dobjectint(apidef.Prefix) %}

interface

uses
{%- if apidef.dcx == 'dc'     %}
   {$I p3compat},
{%- elif apidef.dcx == 'dp'   %}
   sysutils,
{%- elif apidef.dcx == 'dcp'  %}
   sysutils,
   Windows,
{%- elif apidef.dcx == 'dcex' %}
   {$I p3compat},
   pchutil,
   {{ dunit }},
{%- endif %}
   gmsgen
{%- for key,value in apidef.ExtraUse.elements.iterrows() -%},
   {{ value['text'] }}
{%- endfor -%}
;

{% if clibuse -%}
   {%- if apidef.dcx == 'dp'   -%}
{$IFDEF WIN64}
const ExtLib = '{{ apidef.CLib }}64.dll';
{$ELSE}
const ExtLib = '{{ apidef.CLib }}.dll';
{$ENDIF}
   {% endif %}
{%- else -%}
   {%- if apidef.dcx == 'dp'   -%}
{$IFDEF WIN64}
const ExtLib = '{{ apidef.DelphiLib }}64.dll';
{$ELSE}
const ExtLib = '{{ apidef.DelphiLib }}.dll';
{$ENDIF}
   {%- endif %}
{%- endif %}

{%- set tpp   = datadef.tpp.elements['tp'].tolist() -%}

{#- write constants -#}
{{ writeconst() }}

type
   TErrorCallback = function(ErrCount:Integer; const Msg:ShortString):Integer; stdcall;
{%- if ((havetypedefs) and (apidef.dcx != 'dcex' )) %}
{%- for key,value in apidef.tPtrFunc.elements.iterrows() %}
   {{ value['name'] }} =
    {%- if value['type'] == 'void' %} procedure
    {%- else                       %} function
    {%- endif -%}
    (
    {%- set counter = namespace(argpos = 1) -%}
    {%- set ptrf   = apidef.PtrF.elements[apidef.PtrF.elements['name']==value['name']] -%}
    {#%- set argmax = ptrf['apos'].max() -%#}
    {%- set argmax = maxint(ptrf['apos'].tolist() | map('int') | list) -%}
    {%- for pkey, pvalue in ptrf[ptrf['apos'].isin(tpp)].iterrows() -%}
         {%- if apidef.dcx == 'dc' -%} {{ DCall(pvalue['type']) }}
         {%- else                  -%} {{ DPureCall(pvalue['type']) }}
         {%- endif %}
         {%- if pvalue['type'] == 'bool' -%} {{ pvalue['arg'] }}: Integer
         {%- else                        -%} {{ pvalue['arg'] }}: {{ DType(pvalue['type']) }}
         {%- endif -%}
         {%- set intargmax = argmax | int  -%}
         {%- if counter.argpos < intargmax -%} ; {% endif -%}
         {%- set counter.argpos = counter.argpos + 1  -%}
    {%- endfor -%}
    )
    {%- if value['type'] == 'void' -%}
      ;
    {%- else -%}
      : {{ DType(value['type']) }};
    {%- endif %} stdcall;
{%- endfor %}
{%- endif %}

{% if not generic -%}
//tries to load DLL from OS default location
//name for the DLL is automatic
function {{ apidef.Prefix }}GetReady(var Msg: ShortString): boolean;
//tries to load DLL from main program directory; if that fails
//loads DLL from OS default location
//name for the DLL is automatic
function {{ apidef.Prefix }}GetReadyX(var Msg: ShortString): boolean;
//loads DLL from specified directory
//name for the DLL is automatic
function {{ apidef.Prefix }}GetReadyD(const Dir: ShortString; var Msg: ShortString): boolean;
{%- endif %}
//loads DLL from the full path specified
//no changes are made to the name (platform and file extension)
function {{ apidef.Prefix }}GetReadyL(const LibName: ShortString; var Msg: ShortString): boolean;

{% if not generic -%}
//tries to load DLL from OS default location
//name for the DLL is automatic
function {{ apidef.Prefix }}Create(var p{{ apidef.Prefix }}: pointer; var Msg: ShortString): boolean;
//tries to load DLL from main program directory; if that fails
//loads DLL from OS default location
//name for the DLL is automatic
function {{ apidef.Prefix }}CreateX(var p{{ apidef.Prefix }}: pointer; var Msg: ShortString): boolean;
//loads DLL from specified directory
//name for the DLL is automatic
function {{ apidef.Prefix }}CreateD(var p{{ apidef.Prefix }}: pointer; const Dir: ShortString; var Msg: shortString): boolean;
{% if usecd -%}
//loads DLL from specified directory, passes that directory to Constructor
//name for the DLL is automatic
function {{ apidef.Prefix }}CreateDD(var p{{ apidef.Prefix }}: pointer; const Dir: ShortString; var Msg: shortString): boolean;
{% endif -%}
{%- endif -%}

//loads DLL from the full path specified
function {{ apidef.Prefix }}CreateL(var p{{ apidef.Prefix }}: pointer; const LibName: ShortString; var Msg: shortString): boolean;
{%- if apidef.dcx != 'dp' %}
//returns a handle
function  {{ apidef.Prefix }}GetHandle(p{{ apidef.Prefix }}: pointer): pointer;
{%- endif %}

procedure {{ apidef.Prefix }}Free  (var p{{ apidef.Prefix }}: pointer);
{%- if apidef.dcx != 'dp'  %}
procedure {{ apidef.Prefix }}LibraryUnload;
function  {{ apidef.Prefix }}LibraryLoaded: boolean;
{%- endif %}
{% if apidef.dcx in ['dc', 'dcex'] -%}
procedure {{ apidef.Prefix }}CloseDown;
{%- endif %}

{%- if apidef.dcx != 'dp'  %}
function  {{ apidef.Prefix }}GetScreenIndicator: boolean;
procedure {{ apidef.Prefix }}SetScreenIndicator(const ScrInd: boolean);
function  {{ apidef.Prefix }}GetExceptionIndicator: boolean;
procedure {{ apidef.Prefix }}SetExceptionIndicator(const ExcInd: boolean);
function  {{ apidef.Prefix }}GetExitIndicator: boolean;
procedure {{ apidef.Prefix }}SetExitIndicator(const ExtInd: boolean);
function  {{ apidef.Prefix }}GetErrorCount: Integer;
procedure {{ apidef.Prefix }}SetErrorCount(const ecnt: Integer);
function  {{ apidef.Prefix }}GetErrorCallback: TErrorCallback;
procedure {{ apidef.Prefix }}SetErrorCallback(ecb: TErrorCallback);
procedure {{ apidef.Prefix }}ErrorHandling(const Msg: ShortString);

function  {{ apidef.Prefix }}FuncLoaded(address: pointer): boolean;
{%- endif %}
{%- if generic %}
procedure {{ apidef.Prefix }}SolverSet(const pref: ShortString);
{%- endif %}

// functions and procedures
{%- if USE_XXXLOADPATH %}
   {%- if apidef.dcx in ['dc', 'dcp'] %}
var {{ apidef.Prefix }}SetLoadPath : procedure(const s: shortString); stdcall;
var {{ apidef.Prefix }}GetLoadPath : procedure(var s: shortString); stdcall;
   {%- endif %}
   {%- if apidef.dcx == 'dcex' %}
procedure {{ apidef.Prefix }}SetLoadPath (const s: shortString);
procedure {{ apidef.Prefix }}GetLoadPath (var s: shortString);
   {%- endif %}
   {%- if apidef.dcx == 'dp'   %}
procedure {{ apidef.Prefix }}SetLoadPath (const s: shortString); stdcall; external ExtLib;
procedure {{ apidef.Prefix }}GetLoadPath (var s: shortString); stdcall; external ExtLib;
   {%- endif -%}
{%- endif %}
 
{%- if apidef.dcx in ['dc', 'dcp'] %}
var {{ apidef.Prefix }}Initialize : procedure; stdcall;
var {{ apidef.Prefix }}Finalize   : procedure; stdcall;
{%- endif %}

{%- for key,value in apidef.tfunc.elements.iterrows() %}
{%- set fbool = apidef.fbool.elements[ apidef.fbool.elements['name']==value['name'] ] -%}
{%- if ( (apidef.dcx == 'dcex') or
         not( (fbool.shape[0] > 0) or (value['type'] == 'oss' ) )
       ) -%}
  {%- set fe = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
  {%- set len = apidef['idlenF']['value'] - fe['len'].iloc[0]              -%}
  {%- if apidef.dcx in ['dc', 'dcp'] %}
var {{ value['name'] }}{{ prettyWhiteSpace(len) }}:
     {%- if value['type'] == 'void' %} procedure
     {%- else                       %} function
     {%- endif -%}
  {%- else                         -%}
     {%- if value['type'] == 'void' %}
procedure {{ value['name'] }}
     {%- else                       %}
function  {{ value['name'] }}
     {%- endif -%}
  {%- endif %} (p{{ apidef.Prefix }}: pointer
  {%- set counter = namespace(pos = 1) -%}
  {%- set fetpp = fe[fe['pos'].isin(tpp)]                                  -%}
  {%- set arg = fetpp.shape[0]                                             -%}
  {%- for fkey,fvalue in fetpp.iterrows() -%}
     {%- if fvalue['name'] == value['name'] -%}
         {%- if counter.pos == 1 -%} ; {%- endif -%}
         {%- if fvalue['type'] != 'funcptr' -%}
            {%- if apidef.dcx in ['dc', 'dcex']  %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
            {%- elif apidef.dcx in ['dp', 'dcp'] %} {{ DPureCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
            {%- endif -%}
         {%- else                           -%}
            {%-if apidef.FuncMap.elements.shape[0] > 0 -%}
               {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
               {%- for fmkey,fmvalue in funcmap[funcmap['fpos']==fvalue['pos']].iterrows() if funcmap.shape[0] > 0 -%}
                  {%- if  apidef.dcx in ['dc', 'dcex'] %} {{ DCall(fvalue['type'])}}{{fvalue['arg']}}: {{ fmvalue['name'] }}
                  {%- elif apidef.dcx in ['dp', 'dcp'] %} {{ DPureCall(fvalue['type']) }}{{fvalue['arg']}}: {{ fmvalue['name'] }}
                  {%- endif -%}
               {% endfor %}
            {%- endif -%}
         {%- endif -%}
         {%- if counter.pos < arg -%} ; {%- endif -%}
         {%- set counter.pos = counter.pos + 1 -%}
     {%- endif -%}
  {%- endfor -%}
  )
  {%- if value['type'] == 'void'      -%} ;
  {%- elif value['type'] == 'funcptr' -%}
      {%- set fm = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- for fmkey,fmvalue in fm.iterrows() -%} : {{ fmvalue['name'] }};
      {%- endfor -%}
  {%- else -%}
      : {{ DType(value['type']) }};
  {%- endif %} stdcall;
  {%- if  apidef.dcx == 'dp' %} external ExtLib; {% endif %}
{%- endif %}
{%- endfor %}

{#-  write properties -#}
{%- if apidef.pn.elements.shape[0] > 0 %}

// properties as functions and procedures
{%- endif %}

{%- for key,value in apidef.pn.elements.iterrows() %}
{%- if ( (apidef.dcx == 'dcex') or
         not ((value['type'] == 'bool') or (value['type'] == 'oss') and (value['pactions'] == 'r'))
       ) -%}
   {%- set len = apidef['idlenP']['value'] - value['len'] -%}
   {%- if apidef.dcx in ['dc', 'dcp'] %}
var {{ value['name'] }}
   {%- endif -%}
   {%- if value['pactions'] == 'r' -%}
      {%- if value['type'] != 'funcptr' -%}
         {%- if apidef.dcx in ['dc', 'dcp']     %}{{ prettyWhiteSpace(len+3) }}: function  (p{{ apidef.Prefix }}: pointer): {{ DType(value['type']) }}; stdcall;
         {%- elif apidef.dcx in ['dp', 'dcex']  %}
function  {{ value['name'] }} (p{{ apidef.Prefix }}: pointer): {{ DType(value['type']) }}; stdcall;
         {%- endif -%}
      {%- else                          -%}
        {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
        {%- for fmkey,fmvalue in funcmap[funcmap['fpos'] == 'p'].iterrows() -%}
            {%- if apidef.dcx in ['dc', 'dcp']    -%} : function  (p{{ apidef.Prefix }}: pointer): {{ DType(value['type']) }}; stdcall;
            {%- elif apidef.dcx in ['dp', 'dcex']  %}
function  {{ fmvalue['def'] }} (p{{ apidef.Prefix }}: pointer): {{ DType(value['type']) }}; stdcall;
            {%- elif apidef.dcx == 'dp'           -%} external ExtLib;
            {%- endif -%}
        {%- endfor -%} {#- FuncMap -#}
      {%- endif -%} {#- value['type'] != 'funcptr' -#}
   {%- else                        -%}
      {%- if value['type'] != 'funcptr' -%}
         {%- if apidef.dcx in ['dc', 'dcp']    -%} Set{{ prettyWhiteSpace(len) }}: procedure (p{{ apidef.Prefix }}: pointer; const x: {{ DType(value['type']) }}); stdcall;
         {%- elif apidef.dcx in ['dp', 'dcex']  %}
procedure {{ value['name'] }}Set(p{{ apidef.Prefix }}: pointer; const x: {{ DType(value['type']) }}); stdcall;
         {%- endif -%}
      {%- else                           -%}
         {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
         {%- for fmkey,fmvalue in funcmap[funcmap['fpos'] == 'p'].iterrows() -%}
            {%- if apidef.dcx in ['dc', 'dcp']    -%} Set{{ prettyWhiteSpace(len) }}: procedure  (p{{ apidef.Prefix }}: pointer; const x: {{ fmvalue['name'] }}); stdcall;
            {%- elif apidef.dcx in ['dp', 'dcex'] -%} procedure {{ fmvalue['def'] }}Set(p{{ apidef.Prefix }}: pointer): {{ fmvalue['name'] }}; stdcall;
            {%- elif apidef.dcx == 'dp'           -%} external ExtLib;
            {%- endif -%}
         {%- endfor -%} {#- FuncMap -#}
      {%- endif -%}
   {%- endif %}
{%- endif  -%}
{%- endfor %}


{%- if apidef.dcx != 'dcex' -%}
{%- for key,value in apidef.tfunc.elements.iterrows() -%}
   {%- set fbool = apidef.fbool.elements[apidef.fbool.elements['name']==value['name']] -%}
   {%- if (fbool.shape[0] > 0) or (value['type'] == 'oss') -%}
      {%- if value['type'] == 'void' %}
procedure {{ value['name'] }}
      {%- else                       %}
function {{ value['name'] }}
      {%- endif -%}
(p{{ apidef.Prefix }}: pointer
      {%- set fe = apidef.f.elements[apidef.f.elements['name']==value['name']] -%} 
      {%- set argmax = maxint(fe['pos'].tolist() | map('int') | list)          -%}
      {%- set intargmax = argmax | int                                         -%}
      {%- if intargmax > 0 %}; {%- endif -%}
      {%- set counter = namespace(argpos = 1) -%}
      {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() -%}
         {%- if fvalue['type'] != 'funcptr' -%}
            {%- if apidef.dcx in ['dc', 'dcex']  %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
            {%- elif apidef.dcx in ['dp', 'dcp'] %} {{ DPureCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
            {%- endif %}
         {%- else                           -%}
            {%-if apidef.FuncMap.elements.shape[0] > 0 -%}
               {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
               {%- for fmkey,fmvalue in funcmap[funcmap['fpos']==fvalue['pos']].iterrows() if funcmap.shape[0] > 0 -%}
                  {%- if apidef.dcx in ['dc', 'dcex']  %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
                  {%- elif apidef.dcx in ['dp', 'dcp'] %} {{ DPureCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
                  {%- endif %}
               {%- endfor -%} {#- FuncMap -#}
            {%- endif -%}
         {%- endif -%}
         {%- set intargpos = argmax | int  -%}
         {%- if counter.argpos < intargpos -%}; {%- endif -%}
         {%- set counter.argpos = counter.argpos + 1 -%}
      {%- endfor -%}
)
      {%- if value['type'] == 'void'      -%} ;
      {%- elif value['type'] == 'funcptr' -%}
         {% for fmkey,fmvalue in apidef.FuncMap.elements[apidef.FuncMap.elements['name']==value['name']].iterrows() -%}
           : {{ fmvalue['name'] }};
         {% endfor %} {#- FuncMap -#}
      {%- else                            -%}
           : {{ DType(value['type']) }};
      {%- endif %} stdcall;
   {%- endif %}
{%- endfor %}

{%- for key,value in apidef.pn.elements.iterrows() -%}
   {%- if ((value['type'] == 'bool') or (value['type'] == 'oss') and (value['pactions'] == 'r')) %}
      {%- if value['pactions'] == 'r' %}
function {{ value['name'] }}(p{{ apidef.Prefix }}: pointer): {{ DType(value['type']) }}; stdcall;
      {%- else                        %}
procedure {{ value['name'] }}Set(p{{ apidef.Prefix }}: pointer; const x: {{ DType(value['type']) }}); stdcall;
      {%- endif %}
   {%- endif %}
{%- endfor %}
{%- endif %}

implementation

{% if apidef.dcx in ['dc', 'dcex'] -%}
uses
   gmslibname;
{% endif %}
{%- if apidef.dcx != 'dp' %}
const
{%- endif %}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   APIVersion     = {{ apidef['APIVersion'] }};
{%- endif %}
{%- if apidef.dcx != 'dp' %}
   DLLWrapsObject = true;
{%- endif %}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   Debug          = false;
{% endif -%}
{% if apidef.dcx == 'dcp' %}
{$IFDEF VER130}
// From Delphi7 system, sysutils units
   PathDelim  = {$IFDEF MSWINDOWS} '\'; {$ELSE} '/'; {$ENDIF}
type
   IntegerArray  = array[0..$effffff] of Integer;
   PIntegerArray = ^IntegerArray;

function ExcludeTrailingPathDelimiter(const S: string): string;
begin
Result := S;
if IsPathDelimiter(Result, Length(Result))
then
   SetLength(Result, Length(Result)-1);
end;
{$ENDIF}
{% endif -%}
{% if apidef.dcx != 'dp' %}
var
{%- endif %}
{%- if apidef.dcx in ['dc', 'dcex'] %}
   libMutex,
   objMutex,
   exceptMutex       : TStdMutex;
   LibHandle         : TLibHandle;
{%- endif %}
{%- if apidef.dcx == 'dcp' %}
   LibHandle         : THandle;
{%- endif -%}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   LibFileName       : ShortString;
{%- endif %}
{%- if apidef.dcx != 'dp'  %}
   ScreenIndicator   : Boolean = true;
   ExceptionIndicator: Boolean = false;
   ExitIndicator     : Boolean = true;
   ObjectCount       : Integer = 0;
   APIErrorCount     : Integer = 0;
   ErrorCallback     : TErrorCallback = nil;
{% endif -%}
{%- if generic %}
   SlvPrefix         : ShortString = 'xxx';
{% endif -%}

{%- if apidef.dcx in ['dc', 'dcp'] %}
var {{ apidef.prexfix }}Create: procedure (var p{{ apidef.Prefix }}: pointer); stdcall;
   {%- if usecd  %}
var {{ apidef.prexfix }}CreateD: procedure (var p{{ apidef.Prefix }}: pointer; const Dir: shortString); stdcall;
   {%- endif %}
var {{ apidef.prexfix }}Free  : procedure (var p{{ apidef.Prefix }}: pointer); stdcall;

var {{ apidef.prexfix }}APIVersion: function (const api: integer; var msg: ShortString; var comp: Integer): Integer; stdcall;
var {{ apidef.prexfix }}Check: function (const funcn: shortString; const NrArg: integer; const sign: PIntegerArray; var msg: ShortString): Integer; stdcall;
{%- endif %}

{%- if apidef.dcx == 'dp' %}
procedure {{ apidef.prexfix }}Create(var p{{ apidef.Prefix }}: pointer); stdcall; external ExtLib;
   {%- if usecd  %}
procedure {{ apidef.prexfix }}CreateD(var p{{ apidef.Prefix }}: pointer; const Dir: shortString); stdcall; external ExtLib;
   {%- endif %}
procedure {{ apidef.prexfix }}Free  (var p{{ apidef.Prefix }}: pointer); stdcall; external ExtLib;
{%- endif -%}

{%- if apidef.dcx == 'dcex' %}
procedure {{ apidef.prexfix }}Create(var p{{ apidef.Prefix }}: pointer); stdcall;
var
   Msg: Shortstring;
begin
p{{ apidef.Prefix }} := {{ dunit }}.{{ dobjectint }}.create(Msg);
end;

 {%- if usecd  %}
procedure {{ apidef.prexfix }}CreateD(var p{{ apidef.Prefix }}: pointer; const Dir: shortString); stdcall;
var
   Msg: Shortstring;
begin
p{{ apidef.Prefix }} := {{ dunit }}.{{ dobjectint }}.createD(Dir, Msg);
end; {%- endif %}

procedure {{ apidef.prexfix }}Free (var p{{ apidef.Prefix }}: pointer); stdcall;
begin
if p{{ apidef.Prefix }} <> nil
then
   begin
   {{ dobjectint }}(p{{ apidef.Prefix }}).Free;
   p{{ apidef.Prefix }} := nil;
   end;
end;
{%- endif %}

{%- for key,value in apidef.tfunc.elements.iterrows() -%}
{%- set arg = apidef.farg.elements[apidef.farg.elements['name']==value['name']]       -%}
{%- set fbool = apidef.fbool.elements[ apidef.fbool.elements['name']==value['name'] ] -%}
{%- if ( (apidef.dcx != 'dcex') and ((fbool.shape[0] > 0) or (value['type'] == 'oss' ))
       ) -%}
  {%- if apidef.dcx in ['dc', 'dcp'] -%}
     {%- if value['type'] == 'oss' %}
var sst_{{ value['name'] }}:
     {%- else                      %}
var bool_{{ value['name'] }}:
     {%- endif -%}
     {%- if value['type'] in ['void', 'oss'] %} procedure
     {%- else                                %} function
     {%- endif -%}
  {% else                           -%}
     {%- if value['type'] in ['void', 'oss'] %} procedure
     {%- else                                %} function
     {%- endif -%}
     {%- if value['type'] == 'oss' %} sst_{{ value['name'] }}
     {%- else                      %} bool_{{ value['name'] }}:
     {%- endif -%}
  {%- endif -%}
  (p{{ apidef.Prefix }}: pointer
  {%- set counter = namespace(pos = 1) -%}
  {%- set fe    = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
  {%- set fetpp = fe[fe['pos'].isin(tpp)]                                     -%}
  {%- for fkey,fvalue in fetpp.iterrows() -%}
      {%- if counter.pos == 1 -%} ; {%- endif -%}
      {%- if fvalue['type'] != 'funcptr' -%}
         {%- if apidef.dcx in ['dc', 'dcex']  %} {{ DCall(fvalue['type']) }}{{fvalue['arg']}}:
         {%- elif apidef.dcx in ['dp', 'dcp'] %} {{ DPureCall(fvalue['type']) }}{{fvalue['arg']}}:
         {%- endif -%}
         {%- if fvalue['type'] in ['bool', 'vbool'] %} Integer
         {%- else                                   %} {{ DType(fvalue['type']) }}
         {%- endif -%}
      {%- else                            -%}
         {%-if apidef.FuncMap.elements.shape[0] > 0 -%}
            {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
            {%- for fmkey,fmvalue in funcmap[funcmap['fpos']==fvalue['pos']].iterrows() if funcmap.shape[0] > 0 -%}
               {%- if apidef.dcx in ['dc', 'dcex']   %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
               {%- elif apidef.dcx in ['dp', 'dcp']  %} {{ DPureCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
               {%- endif -%}
            {%- endfor %}
         {%- endif -%}
      {%- endif -%}
      {%- if counter.pos < fetpp.shape[0] -%} ; {%- endif -%}
      {%- set counter.pos = counter.pos + 1 -%}
  {%- endfor -%}
  {%- if value['type'] == 'oss' %}; var sst_result: ShortString {%- endif -%}
  )
  {%- if value['type'] in ['void','oss'] -%} ;
  {%- elif value['type'] == 'funcptr'    -%}
      {% set fm = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {% for fmkey,fmvalue in fm.iterrows() -%} : {{fvalue['name'] }};
      {% endfor %}
  {%- elif value['type'] == 'bool'       -%} : Integer;
  {%- else                               -%} : {{ DType(value['type']) }};
  {%- endif %} stdcall;
  {%- if apidef.dcx == 'dp' -%}  external ExtLib name '{{ value['name']}}'; {% endif %}
{%- endif %}
{%- endfor %}

{%- for key,value in apidef.pn.elements.iterrows() %}
{%- if ((value['type'] == 'bool') or ((value['type'] == 'oss') and (value['pactions'] == 'r'))) %}
   {%- if value['pactions'] == 'r' %}
      {%- if value['type'] == 'oss' %}
        {%- if apidef.dcx in ['dc', 'dcp'] %}
var sst_{{ value['name'] }}: procedure  (p{{ apidef.Prefix }}: pointer; var sst_result: ShortString); stdcall;
        {%- elif apidef.dcx == 'dp'        %}
procedure sst_{{ value['name'] }}(p{{ apidef.Prefix }}: pointer; var sst_result: ShortString); stdcall; external ExtLib name '{{ value['name'] }}';
        {%- endif                          %}
      {%- elif value['type'] == 'bool'     %}
        {%- if apidef.dcx in ['dc', 'dcp'] %}
var bool_{{ value['name'] }}: function  (p{{ apidef.Prefix }}: pointer): Integer; stdcall;
        {%- elif apidef.dcx == 'dp'        %}
function  bool_{{ value['name'] }}(p{{ apidef.Prefix }}: pointer): Integer; stdcall; external ExtLib name '{{ value['name'] }}';
        {%- endif                          %}
      {%- endif                          %}
   {%- else %}
      {%- if apidef.dcx in ['dc', 'dcp'] %}
var bool_{{ value['name'] }}Set: procedure  (p{{ apidef.Prefix }}: pointer; const x: Integer); stdcall;
      {%- elif apidef.dcx == 'dp'        %}
procedure bool_{{ value['name'] }}Set(p{{ apidef.Prefix }}: pointer; const x: Integer); stdcall; external ExtLib name '{{ value['name'] }}Set';
      {%- endif                          %}
   {%- endif -%}
{%- endif -%}
{%- endfor %}

{# ToDo put$(dcx<>dcex and sum(tprop(en,ta)$(sameas(ta,'oss') or sameas(ta,'bool')),1) + sum(tfunc(en,ta)$sameas(ta,'oss'),1) + sum(fbool,1)) /; -#}
{%- if apidef.dcx == 'dc' -%}
{%- endif -%}

{% if apidef.dcx in ['dc', 'dcp'] -%}
{%- for key,value in apidef.tfunc.elements.iterrows() -%}
   {{ functionsDescription(value['text']) }}
   {%- if value['type'] == 'void' %}
procedure
   {%- else                       %}
function
   {%- endif %} d_{{ value['name'] }}(p{{ apidef.Prefix }}: pointer
   {%- set arg = apidef.farg.elements[apidef.farg.elements['name']==value['name']] -%}
   {%- set counter = namespace(argpos = 1)                                         -%}
   {%- set fe    = apidef.f.elements[apidef.f.elements['name']==value['name']]     -%}
   {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() -%}
      {%- if counter.argpos == 1 -%} ; {%- endif -%}
      {%- if fvalue['type'] != 'funcptr' -%}
         {%- if apidef.dcx == 'dc'    %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
         {%- elif apidef.dcx == 'dcp' %} {{ DPureCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
         {%- endif -%}
      {%- else                           -%}
         {%-if apidef.FuncMap.elements.shape[0] > 0 -%}
            {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
            {%- for fmkey,fmvalue in funcmap[funcmap['fpos']==fvalue['pos']].iterrows() if funcmap.shape[0] > 0 -%}
               {%- if apidef.dcx == 'dc'     %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
               {%- elif apidef.dcx == 'dcp'  %} {{ DPureCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
               {%- endif -%}
            {%- endfor -%}
         {%- endif -%}
      {%- endif -%}
      {%- if arg.shape[0] > 0 -%} {%- if counter.argpos < arg['value'].iloc[0] -%} ; {%- endif -%}
      {%- set counter.argpos = counter.argpos + 1 -%}
      {%- endif -%}
   {%- endfor -%}
  )
   {%- if value['type'] == 'void'      -%} ;
   {%- elif value['type'] == 'funcptr' -%}
      {%- set fm = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- for fmkey,fmvalue in fm.iterrows() -%} : {{ fmvalue['name'] }};
      {%- endfor -%}
   {%- else                            -%} : {{ DType(value['type']) }};
   {%- endif %} stdcall;
var
   d_Msg: ShortString;
   d_sign : Array[0..{{ counter.argpos-1 }}] of Integer;
begin
d_sign[0] := {{ taind(value['type']) }};
   {%- set fe    = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
   {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() %} d_sign[{{ fvalue['pos'] }}] := {{ taind(fvalue['type']) }};
   {%- endfor %}
{{ apidef.prexfix }}Check('{{ value['name'] }}', {{ counter.argpos-1 }}, @d_sign, d_Msg);
{{ apidef.Prefix }}ErrorHandling('{{ value['name'] }} could not be loaded from ' + LibFileName + ': ' + d_Msg);
   {%- if value['type'] != 'void' %}
Result := {{ DDefVal(value['type']) }};
   {%- endif %}
end;
{% endfor -%}

{%- for key,value in apidef.pn.elements.iterrows() -%}
   {{ functionsDescription(value['text']) }}
   {%- if value['pactions'] == 'r' %}
      {%- if value['type'] != 'funcptr' %}
function  d_{{ value['name'] }}(p{{ apidef.Prefix }}: pointer): {{ DType(value['type']) }};
      {%- else -%}
         {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
         {%- for fmkey,fmvalue in funcmap[funcmap['fpos'] == 'p'].iterrows() %}
function  d_{{ value['name'] }}(p{{ apidef.Prefix }}: pointer): {{ fmvalue['name'] }};
         {% endfor %}
      {%- endif -%}
   {%- else %}
      {%- if value['type'] != 'funcptr' %}
procedure d_{{ value['name'] }}Set(p{{ apidef.Prefix }}: pointer; const x: {{ DType(value['type']) }});
      {%- else                         -%}
         {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
         {%- for fmkey,fmvalue in funcmap[funcmap['fpos'] == 'p'].iterrows() -%}
procedure d_{{ value['name'] }}Set(p{{ apidef.Prefix }}: pointer; const x: {{ fmvalue['name'] }});
         {% endfor %}
      {%- endif -%}
   {%- endif %}  stdcall;
var
   d_Msg: ShortString;
   {%- if value['pactions'] == 'w' %}
   d_sign : Array[0..1] of Integer;
begin
d_sign[0] := {{ taind('void') }}; d_sign[1] := {{ taind(value['type']) }};
{{ apidef.prexfix }}Check('{{ value['name'] }}Set', 1, @d_sign, d_Msg);
   {%- else                       %}
   d_sign : Array[0..0] of Integer;
begin
d_sign[0] := {{ taind(value['type']) }};
{{ apidef.prexfix }}Check('{{ value['name'] }}', 0, @d_sign, d_Msg);
   {%- endif %}
{{ apidef.Prefix }}ErrorHandling('{{ value['name'] }}
   {%- if value['pactions'] == 'w' -%} Set
   {%- endif %} could not be loaded from ' + LibFileName + ': ' + d_Msg);
   {%- if not ((value['type'] == 'void') or (value['pactions'] == 'w')) %}
Result := {{ DDefVal(value['type']) }};
   {%- endif %}
end;
{% endfor -%}
{%- endif %}

{%- if apidef.dcx != 'dcex' -%}
{%- for key,value in apidef.tfunc.elements.iterrows() -%}
{%- set bool = apidef.fbool.elements[ apidef.fbool.elements['name']==value['name'] ] -%}
{%- if ((bool.shape[0] > 0) or (value['type'] == 'oss')) -%}
    {{ functionsDescription(value['text']) }}
    {%- if value['type'] == 'void' %}
procedure {{ value['name'] }}
    {%- else                       %}
function {{ value['name'] }}
    {%- endif -%}
(p{{ apidef.Prefix }}: pointer
    {%- set counter = namespace(argpos = 1) -%}
    {%- set arg = apidef.farg.elements[apidef.farg.elements['name']==value['name']] -%}
    {%- set fe = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
    {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() -%}
      {%- if counter.argpos == 1 -%} ; {%- endif -%}
      {%- if fvalue['type'] != 'funcptr' -%}
         {%- if apidef.dcx in ['dc', 'dcex']  %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
         {%- elif apidef.dcx in ['dp', 'dcp'] %} {{ DPureCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
         {%- endif -%}
      {%- else                           -%}
         {%-if apidef.FuncMap.elements.shape[0] > 0 -%}
            {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
            {#%- set counter = namespace(fmpos = 1) -%#}
            {%- for fmkey,fmvalue in funcmap[funcmap['fpos']==fvalue['pos']].iterrows() if funcmap.shape[0] > 0 -%}
               {%- if apidef.dcx in ['dc', 'dcex']  %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
               {%- elif apidef.dcx in ['dp', 'dcp'] %} {{ DelphiDefVal }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
               {%- endif -%}
            {%- endfor -%} {#- FuncMap -#}
         {%- endif -%}
      {%- endif -%}
      {%- if arg.shape[0] > 0 -%} {%- if counter.argpos < arg['value'].iloc[0] -%} ; {%- endif -%}
      {%- set counter.argpos = counter.argpos + 1 -%}
      {%- endif -%}
    {%- endfor -%} {#- f -#}
)
    {%- if value['type'] == 'void'      -%} ;
    {%- elif value['type'] == 'funcptr' -%}
      {%- for fmkey,fmvalue in apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']].iterrows() -%}
: {{ fmvalue['name'] }};
      {%- endfor -%}
    {%- else -%}
: {{ DType(value['type']) }};
    {%- endif %} stdcall;
    {%- set f     = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
    {%- set ftpp  = f[f['pos'].isin(tpp)]                                       -%}
    {%- set vbool = ftpp[ftpp['type']=='vbool']                                 -%}
    {% if vbool.shape[0] > 0 %}
var
      {%- for fkey,fvalue in vbool.iterrows() %}
   ib_{{ fvalue['arg'] }} : Integer;
      {%- endfor -%} {#- vbool -#}
    {%- endif %}
begin
    {%- for fkey,fvalue in vbool.iterrows() %}
ib_{{ fvalue['arg'] }} := Integer({{ fvalue['arg'] }});
    {%- endfor -%} {#- vbool -#}
    {%- if ((value['type'] != 'void') and (value['type']!='oss')) %}
result :=
       {%- if value['type']=='oss' %} sst_
       {%- else                    %} bool_
       {%- endif -%}
    {%- else                                                     -%}
       {%- if value['type']=='oss' %}
sst_
       {%- else                    %}
bool_
       {%- endif -%}
    {%- endif -%}
{{ value['name'] }}(p{{ apidef.Prefix }}
    {%- for fkey,fvalue in ftpp.iterrows() -%}
      {%- if fvalue['type']=='vbool'  %}, ib_{{ fvalue['arg'] }}
      {%- elif fvalue['type']=='bool' %}, Integer({{ fvalue['arg'] }})
      {%- else                        %}, {{ fvalue['arg'] }}
      {%- endif -%}
    {%- endfor -%}
    {%- if value['type']=='oss'   %}, result {%- endif -%}
)
    {%- if value['type']=='bool'  %} <> 0   {%- endif -%}
;
    {%- for fkey,fvalue in vbool.iterrows() %}
{{ fvalue['arg'] }} := ib_{{ fvalue['arg'] }} <> 0;
    {%- endfor %}
end;
{% endif -%} {# ((bool.shape[0] > 0) or (value['type'] == 'oss')) #}
{%- endfor -%}{#- tfunc #}

{%- for key,value in apidef.pn.elements.iterrows() -%}
{%- if ((value['type']=='bool') or ((value['type']=='oss') and (value['pactions'] == 'r'))) -%}
      {{ functionsDescription(value['text']) }}
      {%- if value['pactions'] == 'r' %}
function {{ value['name'] }}(p{{ apidef.Prefix }}: pointer): {{ DType(value['type']) }}; stdcall;
begin
         {%- if value['type'] == 'oss' %}
sst_{{ value['name'] }}(p{{ apidef.Prefix }}, result);
         {%- else                      %}
result := bool_{{ value['name'] }}(p{{ apidef.Prefix }}) <> 0;
         {%- endif %}
end;
      {%- else                        %}
procedure {{ value['name'] }}Set(p{{ apidef.Prefix }}: pointer; const x: {{ DType(value['type']) }}); stdcall;
begin
bool_{{ value['name'] }}Set(p{{ apidef.Prefix }}, Integer(x));
end;
      {%- endif %}
{% endif %}
{%- endfor -%} {#- pn -#}
{%- endif -%} {#- apidef.dcx != 'dcex' #}

{%- if apidef.dcx != 'dp' %}
function  {{ apidef.Prefix }}GetScreenIndicator: boolean;
begin
Result := ScreenIndicator;
end;

procedure {{ apidef.Prefix }}SetScreenIndicator(const ScrInd: boolean);
begin
ScreenIndicator := ScrInd;
end;

function  {{ apidef.Prefix }}GetExceptionIndicator: boolean;
begin
Result := ExceptionIndicator;
end;

procedure {{ apidef.Prefix }}SetExceptionIndicator(const ExcInd: boolean);
begin
ExceptionIndicator := ExcInd;
end;

function  {{ apidef.Prefix }}GetExitIndicator: boolean;
begin
Result := ExitIndicator;
end;

procedure {{ apidef.Prefix }}SetExitIndicator(const ExtInd: boolean);
begin
ExitIndicator := ExtInd;
end;

function  {{ apidef.Prefix }}GetErrorCount: Integer;
begin
Result := APIErrorCount;
end;

procedure {{ apidef.Prefix }}SetErrorCount(const ecnt: Integer);
begin
APIErrorCount := ecnt;
end;

function  {{ apidef.Prefix }}GetErrorCallback: TErrorCallback;
begin
Result := @ErrorCallback;
end;

procedure {{ apidef.Prefix }}SetErrorCallback(ecb: TErrorCallback);
begin
{%- endif %}
{%- if apidef.dcx in ['dc', 'dcex'] %}
exceptMutex.lock;
{%- endif %}
{%- if apidef.dcx != 'dp'           %}
ErrorCallback := ecb;
{%- endif %}
{%- if apidef.dcx in ['dc', 'dcex'] %}
exceptMutex.unlock;
{%- endif %}
{%- if apidef.dcx != 'dp' %}
end;

procedure {{ apidef.Prefix }}ErrorHandling(const Msg: ShortString);
begin
inc(APIErrorCount);
if ScreenIndicator then begin writeln(Msg); flush(output); end;
assert(not ExceptionIndicator, Msg);
{%- endif %}
{% if apidef.dcx in ['dc', 'dcex'] -%}exceptMutex.lock;     {%- endif %}
{% if apidef.dcx != 'dp'           -%}if (@ErrorCallback <> nil) and (ErrorCallback(APIErrorCount, Msg) <> 0) then halt(123); {%- endif %}
{% if apidef.dcx in ['dc', 'dcex'] -%}exceptMutex.unlock;   {%- endif %}
{% if apidef.dcx != 'dp'           -%}if ExitIndicator then halt(123);
end;
{%- endif %}

{%- if generic %}
procedure {{ apidef.Prefix }}SolverSet(const pref: ShortString);
begin
SlvPrefix  := pref;
end;
{%- endif %}

{%- if (USE_XXXLOADPATH and (apidef.dcx == 'dcex')) %}
procedure {{ apidef.Prefix }}SetLoadPath(const s: shortString);
begin
end;
procedure {{ apidef.Prefix }}GetLoadPath(var   s: shortString);
begin
s := 'Not using a dynamic library';
end;
{% endif %}

{%- set cntf = apidef.tfunc.elements.shape[0] + apidef.pn.elements.shape[0] -%}
{% if apidef.dcx in ['dc', 'dcp'] %}

const NoOfEntryPts = {{ cntf }};
var AddrOfFuncLoaded: Array[1..NoOfEntryPts] of Pointer;
{% endif %}
{% if apidef.dcx != 'dp' %}
function {{ apidef.Prefix }}FuncLoaded(address: pointer): boolean;
{% endif -%}
{% if apidef.dcx in ['dc', 'dcp'] -%}
var
   cnt: Integer;
{% endif -%}
{% if apidef.dcx != 'dp' -%}
begin
{%- endif %}
{% if apidef.dcx in ['dc', 'dcp'] -%}
result := false;
for cnt:=1 to NoOfEntryPts
do if address = AddrOfFuncLoaded[cnt]
   then
      begin
      result := true;
      break;
      end;
{% endif -%}
{% if apidef.dcx == 'dcex' -%}
result := true;
{% endif -%}
{% if apidef.dcx != 'dp'   -%}
end;

function XLibraryLoad(var LoadMsg: ShortString): boolean;
{%- endif %}
{%- if apidef.dcx in ['dc', 'dcp'] %}
var
   comp: Integer;
   sign: Array[0..{{ apidef.fargmax['value'] }}] of Integer;
   funcCount: Integer;
{% endif -%}
{%- if generic %}
   LngPrefix : ShortString;
   RegPrefix : ShortString;
   StrPrefix : ShortString;
{% endif %}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   function LoadEntry(const Name: ShortString; const NoArgs: Integer; const d_x: Pointer): pointer;
{%- if apidef.dcx == 'dcp' %}
   var
      NameX: Ansistring;
{%- endif %}
   begin
   Result := nil;
   if (comp >= 0) then inc(funcCount);
{%- if clibuse %}
   if (comp < 0) or ({{ apidef.prexfix }}Check(copy(Name, 4, length(Name)), NoArgs, @sign, LoadMsg) > 0)
{%- else %}
   if (comp < 0) or ({{ apidef.prexfix }}Check(Name, NoArgs, @sign, LoadMsg) > 0)
{%- endif %}
{%- if generic %}
   then
      begin
      Result := P3GetProcAddress(LibHandle, LowerCase(LngPrefix + Name));
      if Result = nil
      then
         Result := P3GetProcAddress(LibHandle, LngPrefix + Name);
      if Result = nil
      then
         Result := P3GetProcAddress(LibHandle, UpperCase(LngPrefix + Name));
      if Result = nil
      then
{%- else %}
   then
      begin
{%- if apidef.dcx == 'dcp' %}
      NameX := LowerCase(Name);
      Result := GetProcAddress(LibHandle, PAnsiChar(NameX));
{% endif -%}
{%- if apidef.dcx == 'dc' %}
      Result := P3GetProcAddress(LibHandle, LowerCase(Name));
{%- endif %}
      if Result = nil
      then
{%- if apidef.dcx == 'dcp' %}
         begin
         NameX := Name;
         Result := GetProcAddress(LibHandle, PAnsiChar(NameX));
         end;
{% endif -%}
{%- if apidef.dcx == 'dc' %}
         Result := P3GetProcAddress(LibHandle, Name);
{%- endif %}
      if Result = nil
      then
{%- if apidef.dcx == 'dcp' %}
         begin
         NameX := UpperCase(Name);
         Result := GetProcAddress(LibHandle, PAnsiChar(NameX));
         end;
{% endif -%}
{%- if apidef.dcx == 'dc' %}
         Result := P3GetProcAddress(LibHandle, UpperCase(Name));
{%- endif %}
      if Result = nil
      then
{%- endif -%} {# generic #}
         LoadMsg := 'Entry not found: ' + Name + ' in ' + LibFileName;
      end;
   if (comp >= 0) then AddrOfFuncLoaded[funcCount] := Result;
   if Result = nil
   then
      Result := d_x;
   if Debug and (LoadMsg <> '') then {{ apidef.Prefix }}ErrorHandling(LoadMsg);
   end;
{%- if apidef.dcx == 'dcp' %}
var
{$IFDEF UNICODE}
   LibFileNameX: WideString;
{$ELSE}
   LibFileNameX: AnsiString;
{$ENDIF}
{%- endif %}

begin
Result  := false;
LoadMsg := '';
{%- if generic %}
LngPrefix := '';
RegPrefix := '';
StrPrefix := '';
if SlvPrefix = 'xxx'
then
   begin
   LoadMsg := 'Cannot load library before {{ apidef.Prefix }}SolverSet was called!';
   exit;
   end;

{% endif -%} {# generic #}
{%- if apidef.dcx == 'dc'  %}
if LibHandle <> nil
{% endif -%}
{%- if apidef.dcx == 'dcp' %}
if LibHandle <> 0
{% endif -%}
then
   begin
   Result := true;
   exit;
   end;
{%- if apidef.dcx == 'dc' %}
LibHandle := P3LoadLibrary(LibFileName, LoadMsg);
if LibHandle = nil
{% endif -%}
{%- if apidef.dcx == 'dcp' %}
LibFileNameX := LibFileName;
{$IFDEF UNICODE}
LibHandle := LoadLibrary(PWideChar(LibFileNameX));
{$ELSE}
LibHandle := LoadLibrary(PAnsiChar(LibFileNameX));
{$ENDIF}
if LibHandle = 0
{% endif -%}
then
   begin
{%- if apidef.dcx == 'dc' %}
   LoadMsg := LoadMsg + ' (problem occurred when trying to load ' + LibFileName + ')';
{%- endif %}
{%- if apidef.dcx == 'dcp' %}
   LoadMsg := 'Cannot load library ' + LibFileName;
{%- endif %}
   exit;
   end;

comp := -1;
{% if apidef.dcx in ['dc', 'dcp'] -%} {#- redundant with outer if -#}
funcCount := 0;
{% endif -%}
{%- if USE_XXXLOADPATH %}
@{{ apidef.Prefix }}SetLoadPath := LoadEntry('{{ apidef.Prefix }}SetLoadPath', 0, nil);
@{{ apidef.Prefix }}GetLoadPath := LoadEntry('{{ apidef.Prefix }}GetLoadPath', 0, nil);
{% endif -%}
LoadMsg := '';  //not an error
if DLLWrapsObject
then
   begin
{%- if generic %}
   @{{ apidef.prexfix }}Create := LoadEntry(SlvPrefix + '{{ apidef.prexfix }}Create', 0, nil);
{%- else %}
   @{{ apidef.prexfix }}Create := LoadEntry('{{ apidef.prexfix }}Create', 0, nil);
{%- endif -%} {# generic #}
   if @{{ apidef.prexfix }}Create = nil then exit;
{%- if usecd -%}
  {%- if generic %}
   @{{ apidef.prexfix }}CreateD := LoadEntry(SlvPrefix + '{{ apidef.prexfix }}CreateD', 0, nil);
  {%- else -%}
    {%- if clibuse  %}
   @{{ apidef.prexfix }}CreateD := LoadEntry('D__{{ apidef.prexfix }}CreateD', 0, nil);
    {%- else        %}
   @{{ apidef.prexfix }}CreateD := LoadEntry('{{ apidef.prexfix }}CreateD', 0, nil);
    {%- endif -%}
  {%- endif -%} {#- generic #}
   if @{{ apidef.prexfix }}CreateD = nil then exit;
{%- endif -%} {#- usecd -#}
{%- if generic %}
   @{{ apidef.prexfix }}Free   := LoadEntry(SlvPrefix + '{{ apidef.prexfix }}Free', 0, nil);
{%- else %}
   @{{ apidef.prexfix }}Free   := LoadEntry('{{ apidef.prexfix }}Free', 0, nil);
{%- endif -%} {# generic #}
   if @{{ apidef.prexfix }}Free = nil then exit;
   end;
{% if generic -%}
@{{ apidef.prexfix }}Check := LoadEntry(SlvPrefix + '{{ apidef.prexfix }}Check', 0, nil);
if @{{ apidef.prexfix }}Check = nil
then
   begin
   RegPrefix := 'C__';
   StrPrefix := 'D__';
   LngPrefix := StrPrefix;
   @{{ apidef.prexfix }}Check := LoadEntry(SlvPrefix + '{{ apidef.prexfix }}Check', 0, nil);
   end;
{%- else -%}
  {%- if clibuse  -%}
@{{ apidef.prexfix }}Check := LoadEntry('D__{{ apidef.prexfix }}Check', 0, nil);
  {%- else -%}
@{{ apidef.prexfix }}Check := LoadEntry('{{ apidef.prexfix }}Check', 0, nil);
  {%- endif %}
{% endif -%} {# generic -#}
if @{{ apidef.prexfix }}Check = nil then exit;
{% if generic -%}
@{{ apidef.prexfix }}APIVersion := LoadEntry(SlvPrefix + '{{ apidef.prexfix }}APIVersion', 0, nil);
{%- else -%}
  {%- if clibuse  -%}
@{{ apidef.prexfix }}APIVersion := LoadEntry('D__{{ apidef.prexfix }}APIVersion', 0, nil);
  {%- else -%}
@{{ apidef.prexfix }}APIVersion := LoadEntry('{{ apidef.prexfix }}APIVersion', 0, nil);
  {%- endif %}
{% endif -%} {# generic -#}
if @{{ apidef.prexfix }}APIVersion = nil then exit;

{%- if generic %}
LngPrefix := RegPrefix;
@{{ apidef.Prefix }}Initialize := LoadEntry(SlvPrefix +   'Initialize', 0, nil);
@{{ apidef.Prefix }}Finalize   := LoadEntry(SlvPrefix +   'Finalize', 0, nil);
{%- else -%}
  {%- if clibuse  %}
@{{ apidef.Prefix }}Initialize := LoadEntry('C__{{ apidef.Prefix }}Initialize', 0, nil);
@{{ apidef.Prefix }}Finalize   := LoadEntry('C__{{ apidef.Prefix }}Finalize', 0, nil);
  {%- else        %}
@{{ apidef.Prefix }}Initialize := LoadEntry('{{ apidef.Prefix }}Initialize', 0, nil);
@{{ apidef.Prefix }}Finalize   := LoadEntry('{{ apidef.Prefix }}Finalize', 0, nil);
  {%- endif %}
{% endif -%} {#- generic -#}
if @{{ apidef.Prefix }}Initialize <> nil then {{ apidef.Prefix }}Initialize;
if ({{ apidef.prexfix }}APIVersion(APIversion, LoadMsg, comp) = 0)
then
   exit;
{%- if apidef.dcx in ['dc', 'dcp'] -%} {#- redundant with outer if #}

funcCount := 0;
{% endif -%}

{%- for key,value in apidef.tfunc.elements.iterrows() -%}
  {%- set arg = apidef.farg.elements.loc[apidef.farg.elements['name']==value['name']]    -%}
  {%- if arg.shape[0] < 1 %} {%- set farg = 0 -%}
  {%- else               -%} {%- set farg = arg['value'].iloc[0] -%}
  {%- endif -%}
sign[0] := {{ taind(value['type']) }};
  {%- set fe    = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
  {%- for fkey,fvalue in fe[fe['pos'].isin(tpp)].iterrows() -%}
sign[{{ fvalue['pos'] }}] := {{ taind(fvalue['type']) }};
  {%- endfor -%} {#- f #}

  {%- set enstring = apidef.enstring.elements[ apidef.enstring.elements['name']==value['name'] ] -%}
  {%- set bool = apidef.fbool.elements[ apidef.fbool.elements['name']==value['name'] ] -%}
  {% if generic -%}
    {%- if enstring.shape[0] > 0 -%}
 LngPrefix := StrPrefix;
    {%- else                     -%}
 LngPrefix := RegPrefix;
    {% endif %}
@
    {%- if value['type'] == 'oss' -%} sst_
    {%- elif bool.shape[0] > 0 -%} bool_
{{ value['name'] }} := LoadEntry(SlvPrefix + {{ value['name'] }} ; {{ ToDo }}
    {% endif -%}
  {%- else %}
@
    {%- if value['type'] == 'oss' -%} sst_
    {%- elif bool.shape[0] > 0 -%} bool_
    {%- endif -%}
    {%- if clibuse  -%}
       {%- if enstring.shape[0] > 0 -%}
{{ value['name'] }} := LoadEntry('D__{{ value['name'] }}', {{ farg }}, @d_{{ value['name'] }});
       {%- else                     -%}
{{ value['name'] }} := LoadEntry('C__{{ value['name'] }}', {{ farg }}, @d_{{ value['name'] }});
       {%- endif -%}
    {%- else        -%}
{{ value['name'] }} := LoadEntry('{{ value['name'] }}', {{ farg }}, @d_{{ value['name'] }});
    {%- endif -%}
  {%- endif -%} {#- generic #}
{% endfor -%} {#- tfunc -#}

{% for key,value in apidef.pn.elements.iterrows() %}
  {%- set enstring  = apidef.enstring.elements[ apidef.enstring.elements['name']==value['name'] ]            -%}
  {%- if value['pactions'] == 'w' %}
sign[0] := {{ taind('void') }}; sign[1] := {{ taind(value['type']) }};
  {%- else %}
sign[0] := {{ taind(value['type']) }};
  {%- endif -%}
  {% if generic -%}
    {%- if enstring.shape[0] > 0 -%}
 LngPrefix := StrPrefix;
     {%- else %}
 LngPrefix := RegPrefix;
     {% endif -%}
@
     {%- if ((value['pactions'] == 'r') and (value['type'] == 'oss')) -%} sst_  {%- endif -%}
     {%- if value['type']=='bool'                                     -%} bool_ {%- endif -%}
{{ value['name'] }}
     {%- if value['pactions'] == 'w' -%} Set {%- endif %} := LoadEntry(SlvPrefix + {{ value['name'] }} ;
  {%- else %}
@
     {%- if ((value['pactions'] == 'r') and (value['type'] == 'oss')) -%} sst_  {%- endif -%}
     {%- if value['type']=='bool'                                        -%} bool_ {%- endif -%}
{{ value['name'] }}
     {%- if value['pactions'] == 'w' -%} Set {%- endif -%}
     {% if clibuse -%}
        {%- if enstring.shape[0] > 0 %} := LoadEntry('D__{{ value['name'] }}
        {%- else                     %} := LoadEntry('C__{{ value['name'] }}
        {%- endif -%}
     {%- else %} := LoadEntry('{{ value['name'] }}
     {%- endif -%}
  {%- endif -%} {#- generic -#}
  {%- if value['pactions'] == 'w' -%} Set', 1, @d_{{ value['name'] }}Set);
  {%- else                        -%}    ', 0, @d_{{ value['name'] }});
  {%- endif -%}
{% endfor %} {#- pn #}
Result := true;
end;
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] #}

{% if apidef.dcx == 'dcex' -%}
begin
Result := true;
end;
{% endif -%} {#- apidef.dcx == 'dcex'] -#}

{%- if apidef.dcx != 'dp'  %}
procedure XLibraryUnload;
begin
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx == 'dc'    %}
if LibHandle <> nil
{%- elif apidef.dcx == 'dcp' %}
if LibHandle <> 0
{%- endif %}
{%- if apidef.dcx in ['dc', 'dcp'] %}
then
   begin
   if @{{ apidef.Prefix }}Finalize <> nil
   then
      {{ apidef.Prefix }}Finalize;
{% endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dc'   %}
   P3FreeLibrary(LibHandle);
   LibHandle := nil;
{% endif -%} {#- apidef.dcx == 'dc' -#}
{%- if apidef.dcx == 'dcp'  %}
   FreeLibrary(LibHandle);
   LibHandle := 0;
{% endif -%} {#- apidef.dcx == 'dcp' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   end;

@{{ apidef.prexfix }}Create{{ prettyWhiteSpace(apidef.idlenF['value']-2) }} := nil;
  {%- if usecd %}
@{{ apidef.prexfix }}CreateD{{ prettyWhiteSpace(apidef.idlenF['value']-3) }} := nil;
  {%- endif %}
@{{ apidef.prexfix }}Free{{ prettyWhiteSpace(apidef.idlenF['value']) }} := nil;
@{{ apidef.Prefix }}Initialize{{ prettyWhiteSpace(apidef.idlenF['value']-8) }} := nil;
@{{ apidef.Prefix }}Finalize{{ prettyWhiteSpace(apidef.idlenF['value']-6) }} := nil;
{%- endif -%} {#- apidef.dcx in ['dc', 'dcp'] #}

{%- if apidef.dcx in ['dc', 'dcp'] %}
{% for key,value in apidef.tfunc.elements.iterrows() -%}
   {%- set bool = apidef.fbool.elements[ apidef.fbool.elements['name'] == value['name'] ] -%}
   {%- set len  = apidef.idlenF['value'] - value['len']  %}
@
   {%- if value.type == 'oss'    -%} sst_{{ value['name'] }}{{ prettyWhiteSpace(len+1) }} := nil;
   {%- elif bool.shape[0] > 0    -%} bool_{{ value['name'] }}{{ prettyWhiteSpace(len) }} := nil;
   {%- else                      -%} {{ value['name'] }}{{ prettyWhiteSpace(len+5) }} := nil;
   {%- endif -%}
{%- endfor -%} {#- tfunc -#}

{%- if (USE_XXXLOADPATH and (apidef.dcx in ['dc','dcp'])) %}
@{{ apidef.Prefix }}SetLoadPath := nil;
@{{ apidef.Prefix }}GetLoadPath := nil;
{% endif -%}

{%- for key,value in apidef.pn.elements.iterrows() -%}
   {%- set len  = apidef.idlenP['value'] - value['len'] %}
@
   {%- if ((value['pactions']=='r') and (value['type']=='oss')) -%} sst_
   {%- elif value['type']=='bool'                               -%} bool_
   {%- endif -%}
{{ value['name'] }}
   {%- if value['pactions']=='w' -%} Set
      {%- if value['type']=='bool' %}{{ prettyWhiteSpace(len) }}
      {%- else                     %}{{ prettyWhiteSpace(len+5) }}
      {%- endif -%}
   {%- else                      -%} 
      {%- if value['type']=='oss'    %}{{ prettyWhiteSpace(len+4) }}
      {%- elif value['type']=='bool' %}{{ prettyWhiteSpace(len+3) }}
      {%- else                       %}{{ prettyWhiteSpace(len+8) }}
      {%- endif -%}
   {%- endif %} := nil;
   {%- endfor -%} {#- pn -#}
{% endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}

{% if apidef.dcx != 'dp' %}
end;

function LibLoader(const Path, Name: ShortString; var Msg: ShortString): boolean;
{%- endif -%} {# apidef.dcx != 'dp' #}

{%- if apidef.dcx in ['dc', 'dcp'] %}
var
   xName  : ShortString;
   xPath  : ShortString;
{% endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx != 'dp' %}
begin
{%- endif -%} {# apidef.dcx != 'dp' #}
{%- if apidef.dcx in ['dc', 'dcp'] %}
if Name <> ''
then
   xName := Name
else
{%- endif -%} {#- apidef.dcx in ['dc', 'dcp'] #}
{%- if clibuse -%}
  {%- if apidef.dcx == 'dc' %}
   xName := gamslibnamep3('{{ apidef.CLib }}');
  {%- elif apidef.dcx == 'dcp' %}
{$IFDEF WIN64}
   xName := '{{ apidef.CLib }}64.dll';
{$ELSE}
   xName := '{{ apidef.CLib }}.dll';
{$ENDIF}
  {%- endif %}
{%- else %}
  {%- if apidef.dcx == 'dc' %}
   xName := gamslibnamep3('{{ apidef.DelphiLib }}');
  {%- elif apidef.dcx == 'dcp' %}
{$IFDEF WIN64}
   xName := '{{ apidef.DelphiLib }}64.dll';
{$ELSE}
   xName := '{{ apidef.DelphiLib }}.dll';
{$ENDIF}
  {%- endif %}
{% endif -%} {# clibuse -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
if Path = ''
then
   begin
   xPath       := '';
   LibFileName := xName
   end
else
   begin
   xPath       := ExcludeTrailingPathDelimiter(Path);
   LibFileName := xPath + PathDelim + xName;
   end;

{% endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{% if apidef.dcx != 'dp' -%}
{# for some reason there is no blank between keyword "begin" and this #}
Result := XLibraryLoad(Msg);
{% endif -%} {# apidef.dcx != 'dp' -#}
{%- if (USE_XXXLOADPATH and (apidef.dcx in ['dc', 'dcp'])) -%}
if @{{ apidef.Prefix }}SetLoadPath <> nil
then
   begin
   if Result
   then
      {{ apidef.Prefix }}SetLoadPath(xPath)
   else
      {{ apidef.Prefix }}SetLoadPath('');
   end;
{% endif -%}
{% if apidef.dcx != 'dp' -%}
end;
{% endif -%} {# apidef.dcx != 'dp' -#}

{%- if not generic %}
function {{ apidef.Prefix }}GetReady(var Msg: ShortString): boolean;
begin
{%- if apidef.dcx == 'dc' %}
libMutex.lock;
if LibHandle = nil
{%endif -%} {# apidef.dcx == 'dc' #}
{%- if apidef.dcx == 'dcp' %}
if LibHandle = 0
{% endif -%} {# apidef.dcx == 'dcp' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
then
   Result := LibLoader('', '', Msg)
else
   begin
   Msg := '';
   Result := true
   end;
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] #}
{%- if apidef.dcx in ['dcex', 'dp'] %}
Msg := '';
Result := true;
{%- endif -%} {# apidef.dcx in ['dcex', 'dp'] #}
{%- if apidef.dcx == 'dc' %}
libMutex.unlock;
{% endif -%} {# apidef.dcx == 'dc' #}
end;

function {{ apidef.Prefix }}GetReadyX(var Msg: ShortString): boolean;
begin
{% if apidef.dcx == 'dc' -%}
libMutex.lock;
if LibHandle = nil
{% endif -%} {# apidef.dcx == 'dc' -#}
{% if apidef.dcx == 'dcp' -%}
if LibHandle = 0
{% endif -%} {# apidef.dcx == 'dcp' -#}
{% if apidef.dcx in ['dc', 'dcp'] -%}
then
   begin
   Result := LibLoader(ExtractFilePath(ParamStr(0)), '', Msg);
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] #}
{%- if apidef.dcx == 'dc' %}
   if LibHandle = nil
{% endif -%} {# apidef.dcx == 'dc' -#}
{%- if apidef.dcx == 'dcp' %}
   if LibHandle = 0
{%- endif -%} {# apidef.dcx == 'dcp' #}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   then
      Result := LibLoader('', '', Msg);
   end
else
   begin
   Msg := '';
   Result := true
   end;
{% endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{% if apidef.dcx in ['dcex', 'dp'] -%}
Msg := '';
Result := true;
{% endif -%} {# apidef.dcx in ['dcex', 'dp'] -#}
{% if apidef.dcx == 'dc' -%}
libMutex.unlock;
{% endif -%} {# apidef.dcx == 'dc' -#}
end;

function {{ apidef.Prefix }}GetReadyD(const Dir: ShortString; var Msg: ShortString): boolean;
begin
{% if apidef.dcx == 'dc' -%}
libMutex.lock;
if LibHandle = nil
{% endif -%} {# apidef.dcx == 'dc' -#}
{% if apidef.dcx == 'dcp' -%}
if LibHandle = 0
{% endif -%} {# apidef.dcx == 'dcp' -#}
{% if apidef.dcx in ['dc', 'dcp'] -%}
then
   Result := LibLoader(Dir, '', Msg)
else
   begin
   Msg := '';
   Result := true
   end;
{% endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{% if apidef.dcx in ['dcex', 'dp'] -%}
Msg := '';
Result := true;
{% endif -%} {# apidef.dcx in ['dcex', 'dp'] -#}
{% if apidef.dcx == 'dc' -%}
libMutex.unlock;
{% endif -%} {# apidef.dcx == 'dc' -#}
end;
{%- endif -%} {# not generic #}

function {{ apidef.Prefix }}GetReadyL(const LibName: ShortString; var Msg: ShortString): boolean;
begin
{% if apidef.dcx in ['dcex', 'dc'] -%}
libMutex.lock;
{% endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{% if apidef.dcx == 'dc' -%}
if LibHandle = nil
{% endif -%} {# apidef.dcx == 'dc' -#}
{% if apidef.dcx == 'dcp' -%}
if LibHandle = 0
{% endif -%} {# apidef.dcx == 'dcp' -#}
{% if apidef.dcx in ['dc', 'dcp'] -%}
then
   Result := LibLoader(ExtractFilePath(LibName), ExtractFileName(LibName), Msg)
else
   begin
   Msg := '';
   Result := true
   end;
{% endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{% if apidef.dcx in ['dcex', 'dp'] -%}
Msg := '';
Result := true;
{% endif -%} {# apidef.dcx in ['dcex', 'dp'] -#}
{% if apidef.dcx in ['dcex', 'dc'] -%}
libMutex.unlock;
{% endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
end;

{% if apidef.dcx != 'dp' -%}
function  {{ apidef.Prefix }}GetHandle(p{{ apidef.Prefix }}: pointer): pointer;
begin
Result := p{{ apidef.Prefix }};
end;

{% endif -%} {# apidef.dcx != 'dp' -#}

{% if not generic -%}
function {{ apidef.Prefix }}Create(var p{{ apidef.Prefix }}: pointer; var Msg: ShortString): boolean;
begin
{% if apidef.dcx != 'dp' -%}
Assert(DLLWrapsObject, '{{ apidef.DelphiCall }}.{{ apidef.Prefix }}Create without an Object');
Result := {{ apidef.Prefix }}GetReady(Msg);
if Result
then
   begin
   {{ apidef.prexfix }}Create(p{{ apidef.Prefix }});
   if p{{ apidef.Prefix }} = nil
   then
      begin
      Result := false;
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
      Msg := 'Library is loaded but error while creating object';
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] #}
{%- if apidef.dcx == 'dcex' %}
      Msg := 'Error while creating object';
{%- endif -%} {# apidef.dcx == 'dcex' #}
{%- if apidef.dcx != 'dp' %}
      end
   else
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      begin
      objMutex.lock;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
      inc(ObjectCount);
{%- endif -%} {# apidef.dcx != 'dp' #}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      objMutex.unlock;
      end;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
   end
else
   begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
{% else -%} {# apidef.dcx == 'dp' -#}
{{ apidef.prexfix }}Create(p{{ apidef.Prefix }});
if p{{ apidef.Prefix }} = nil
then
   begin
   Result := false;
   Msg := 'Library is loaded but error while creating object';
   end
else
   result := true;
{% endif -%} {# apidef.dcx != 'dp' -#}
end;

function {{ apidef.Prefix }}CreateX(var p{{ apidef.Prefix }}: pointer; var Msg: ShortString): boolean;
begin
{%- if apidef.dcx != 'dp' %}
Assert(DLLWrapsObject, '{{ apidef.DelphiCall }}.{{ apidef.Prefix }}Create without an Object');
Result := {{ apidef.Prefix }}GetReadyX(Msg);
if Result
then
   begin
   {{ apidef.prexfix }}Create(p{{ apidef.Prefix }});
   if p{{ apidef.Prefix }} = nil
   then
      begin
      Result := false;
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
      Msg := 'Library is loaded but error while creating object';
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] #}
{%- if apidef.dcx == 'dcex' %}
      Msg := 'Error while creating object';
{%- endif -%} {# apidef.dcx == 'dcex' #}
{%- if apidef.dcx != 'dp' %}
      end
   else
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      begin
      objMutex.lock;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
      inc(ObjectCount);
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      objMutex.unlock;
      end;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
   end
else
   begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
{% else -%} {# apidef.dcx == 'dp' -#}
{{ apidef.prexfix }}Create(p{{ apidef.Prefix }});
if p{{ apidef.Prefix }} = nil
then
   begin
   Result := false;
   Msg := 'Library is loaded but error while creating object';
   end
else
   result := true;
{%- endif -%} {# apidef.dcx != 'dp' -#}
end;

function {{ apidef.Prefix }}CreateD(var p{{ apidef.Prefix }}: pointer; const Dir: ShortString; var Msg: shortString): boolean;
begin
{%- if apidef.dcx != 'dp' %}
Assert(DLLWrapsObject, '{{ apidef.DelphiCall }}.{{ apidef.Prefix }}CreateD without an Object');
Result := {{ apidef.Prefix }}GetReadyD(Dir, Msg);
if Result
then
   begin
   {{ apidef.prexfix }}Create(p{{ apidef.Prefix }});
   if p{{ apidef.Prefix }} = nil
   then
      begin
      Result := false;
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
      Msg := 'Library is loaded but error while creating object';
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dcex' %}
      Msg := 'Error while creating object';
{% endif -%} {# apidef.dcx == 'dcex' -#}
{%- if apidef.dcx != 'dp' %}
      end
   else
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      begin
      objMutex.lock;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
      inc(ObjectCount);
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      objMutex.unlock;
      end;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
   end
else
   begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
{% else -%} {# apidef.dcx == 'dp' -#}
{{ apidef.prexfix }}Create(p{{ apidef.Prefix }});' /
if p{{ apidef.Prefix }} = nil
then
   begin
   Result := false;
   Msg := 'Library is loaded but error while creating object';
   end
else
   result := true;
{%- endif -%} {# apidef.dcx != 'dp' -#}
end;

{% if usecd -%}
function {{ apidef.Prefix }}CreateDD(var p{{ apidef.Prefix }}: pointer; const Dir: ShortString; var Msg: shortString): boolean;
begin
{%- if apidef.dcx != 'dp' %}
Assert(DLLWrapsObject, '{{ apidef.DelphiCall }}.{{ apidef.Prefix }}CreateDD without an Object');
Result := {{ apidef.Prefix }}GetReadyD(Dir, Msg);
if Result
then
   begin
   {{ apidef.prexfix }}CreateD(p{{ apidef.Prefix }}, Dir);
   if p{{ apidef.Prefix }} = nil
   then
      begin
      Result := false;
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
      Msg := 'Library is loaded but error while creating object';
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dcex' %}
      Msg := 'Error while creating object';
{% endif -%} {# apidef.dcx == 'dcex' -#}
{%- if apidef.dcx != 'dp' %}
      end
   else
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      begin
      objMutex.lock;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
      inc(ObjectCount);
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      objMutex.unlock;
      end;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
   end
else
   begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
{% else -%} {# apidef.dcx == 'dp' -#}
{{ apidef.prexfix }}CreateD(p{{ apidef.Prefix }}, Dir);
if p{{ apidef.Prefix }} = nil
then
   begin
   Result := false;
   Msg := 'Library is loaded but error while creating object';
   end
else
   result := true;
{%- endif -%} {# apidef.dcx != 'dp' -#}
end;

{% endif %} {#- usecd -#}
{% endif -%} {# not generic -#}

function {{ apidef.Prefix }}CreateL(var p{{ apidef.Prefix }}: pointer; const LibName: ShortString; var Msg: shortString): boolean;
begin
{%- if apidef.dcx != 'dp' %}
Assert(DLLWrapsObject, '{{ apidef.DelphiCall }}.{{ apidef.Prefix }}CreateL without an Object');
Result := {{ apidef.Prefix }}GetReadyL(LibName, Msg);
if Result
then
   begin
   {{ apidef.prexfix }}Create(p{{ apidef.Prefix }});
   if p{{ apidef.Prefix }} = nil
   then
      begin
      Result := false;
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
      Msg := 'Library is loaded but error while creating object';
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dcex' %}
      Msg := 'Error while creating object';
{%- endif -%} {# apidef.dcx == 'dcex' -#}
{%- if apidef.dcx != 'dp' %}
      end
   else
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      begin
      objMutex.lock;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
      inc(ObjectCount);
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dcex', 'dc'] %}
      objMutex.unlock;
      end;
{%- endif -%} {# apidef.dcx in ['dcex', 'dc'] -#}
{%- if apidef.dcx != 'dp' %}
   end
else
   begin
   p{{ apidef.Prefix }} := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
{% else -%} {# apidef.dcx == 'dp' -#}
{{ apidef.prexfix }}Create(p{{ apidef.Prefix }});
if p{{ apidef.Prefix }} = nil
then
   begin
   Result := false;
   Msg := 'Library is loaded but error while creating object';
   end
else
   result := true;
{%- endif -%} {# apidef.dcx != 'dp' -#}
end;

procedure {{ apidef.Prefix }}Free  (var p{{ apidef.Prefix }}: pointer);
begin
{%- if apidef.dcx in ['dc', 'dcp'] %}
if @{{ apidef.prexfix }}Free <> nil
then
   begin
   {{ apidef.prexfix }}Free(p{{ apidef.Prefix }}); p{{ apidef.Prefix }} := nil;
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dc' %}
   objMutex.lock;
{%- endif -%} {# apidef.dcx == 'dc' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   dec(ObjectCount);
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dc' %}
   objMutex.unlock;
{%- endif -%} {# apidef.dcx == 'dc' -#}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   end;
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dcex' %}
{{ apidef.prexfix }}Free(p{{ apidef.Prefix }}); p{{ apidef.Prefix }} := nil;
objMutex.lock;
dec(ObjectCount);
objMutex.unlock;
{%- endif -%} {# apidef.dcx == 'dcex' -#}
{%- if apidef.dcx == 'dp' %}
{{ apidef.prexfix }}Free(p{{ apidef.Prefix }});
{%- endif -%} {# apidef.dcx == 'dp' #}
end;

{% if apidef.dcx != 'dp' -%}
function {{ apidef.Prefix }}LibraryLoaded: boolean;
begin
{%- endif -%} {# apidef.dcx != 'dp' -#}
{%- if apidef.dcx in ['dc', 'dcex'] %}
libMutex.lock;
Result := LibHandle <> nil;
libMutex.unlock;
{%- endif -%} {# apidef.dcx in ['dc', 'dcex'] -#}
{%- if apidef.dcx == 'dcp' %}
Result := LibHandle <> 0;
{%- endif -%} {# apidef.dcx == 'dcp' #}
{%- if apidef.dcx != 'dp' %}
end;

procedure {{ apidef.Prefix }}LibraryUnload;
begin
{%- endif -%} {# apidef.dcx != 'dp' #}
{%- if apidef.dcx == 'dc' %}
libMutex.lock;
if LibHandle <> nil
{%- endif -%} {# apidef.dcx == 'dc' #}
{%- if apidef.dcx == 'dcp' %}
if LibHandle <> 0
{%- endif -%} {# apidef.dcx == 'dcp' #}
{%- if apidef.dcx in ['dc', 'dcp'] %}
then
   begin
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dc' %}
   objMutex.lock;
{%- endif -%} {# apidef.dcx == 'dc' #}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   if ObjectCount<>0
   then
      begin
      writeln('Could not unload library, object not freed.');
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dc' %}
      objMutex.unlock;
      libMutex.unlock;
{%- endif -%} {# apidef.dcx == 'dc' #}
{%- if apidef.dcx in ['dc', 'dcp'] %}
      exit;
      end;
   XLibraryUnload;
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dc' %}
   objMutex.unlock;
{%- endif -%} {# apidef.dcx == 'dc' #}
{%- if apidef.dcx in ['dc', 'dcp'] %}
   end;
{%- endif -%} {# apidef.dcx in ['dc', 'dcp'] -#}
{%- if apidef.dcx == 'dc' %}
libMutex.unlock;
{%- endif -%} {# apidef.dcx == 'dc' #}
{%- if apidef.dcx != 'dp' %}
end;
{%- endif -%} {# apidef.dcx == 'dp' #}

{% if apidef.dcx in ['dc', 'dcex'] -%}
procedure {{ apidef.Prefix }}CloseDown;
begin
FreeAndNil(libMutex);
FreeAndNil(objMutex);
FreeAndNil(exceptMutex);
end;
{%- endif -%} {# apidef.dcx in ['dc', 'dcex'] -#}

{%- if apidef.dcx == 'dcex' %}
{% for key,value in apidef.tfunc.elements.iterrows() -%}
   {%- if value['type'] == 'void' %}
procedure
   {%- else                       %}
function
   {%- endif %} {{ value['name'] }}(p{{ apidef.Prefix }}: pointer
   {%- set counter = namespace(fpos = 1)                                       -%}
   {%- set f     = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
   {%- set fname = f[f['pos'].isin(tpp)]                                       -%}
   {%- for fkey,fvalue in fname.iterrows() -%}
      {%- if counter.fpos == 1 -%} ; {%- endif -%}
      {%- if fvalue['type'] != 'funcptr'  %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
      {%- else                           -%}
         {%- set fmpos = 1                           -%}
         {%- if apidef.FuncMap.elements.shape[0] > 0 -%}
            {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
            {%- set fmtpp   = funcmap[funcmap['fpos'].isin(tpp)]                                     -%}
            {%- for fmkey,fmvalue in fmtpp.iterrows() %} {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
               {%- if fmpos < fmtpp.shape[0] -%} ; {%- endif -%}
               {%- set fmpos = fmpos + 1 -%}
            {%- endfor %} {#- FuncMap -#}
         {%- endif -%}
      {%- endif -%}
      {%- if counter.fpos < fname.shape[0] -%} ; {%- endif -%}
      {%- set counter.fpos = counter.fpos + 1 -%}
   {%- endfor -%} {#- f -#}
)
   {%- if value['type'] == 'void'      -%}
; stdcall;
begin
{{ dobjectint }}(p{{ apidef.Prefix }}).{{ value['name'] }}
   {%- elif value['type'] == 'funcptr' -%}
      {% for fmkey,fmvalue in apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']].iterrows() -%}
: {{ fmvalue['name'] }}; stdcall;
      {%- endfor %} {#- FuncMap #}
begin
result := {{ dobjectint }}(p{{ apidef.Prefix }}).{{ value['name'] }}
   {%- else                        -%}
: {{ DType(value['type']) }}; stdcall;
begin
result := {{ dobjectint }}(p{{ apidef.Prefix }}).{{ value['name'] }}
   {%- endif -%}
   {%- set counter = namespace(pos = 1)                                             -%}
   {%- set farg = apidef.farg.elements[apidef.farg.elements['name']==value['name']] -%}
   {%- if farg.shape[0] > 0 -%} (
      {%- set f    = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
      {%- set ftpp = f[f['pos'].isin(tpp)]                                       -%}
      {%- for fkey,fvalue in ftpp.iterrows() -%}
{{ fvalue['arg'] }}
         {%- if counter.pos < ftpp.shape[0] -%} , {% endif -%}
         {%- set counter.pos = counter.pos + 1 -%}
      {%- endfor -%} {#- f -#}
)
   {%- else                -%}
      {%- if value['type'] == 'funcptr' -%} () {%- endif -%}
   {%- endif -%}
;
end;
{% endfor -%} {#- tfunc -#}

{%- for key,value in apidef.tprop.elements.iterrows() -%}
   {%- set pn = apidef.pn.elements[apidef.pn.elements['name']==value['name']] -%}
   {%- for pkey,pvalue in pn[pn['type']==value['type']].iterrows() %}
      {%- if pvalue['pactions']=='r' -%}
         {%- if pvalue['type'] != 'funcptr' %}
function  {{ value['name'] }}(p{{ apidef.Prefix }}: pointer): {{ DType(pvalue['type']) }}; stdcall;
begin
result := {{ dobjectint }}(p{{ apidef.Prefix }}).{{ value['name'] }};
         {%- else                          -%}
            {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==palue['name']] -%}
            {%- for fmkey,fmvalue in funcmap[funcmap['fpos'] == 'p'].iterrows() %}
function  {{ value['name'] }}(p{{ apidef.Prefix }}: pointer): {{ fmvalue['name'] }}; stdcall;
begin
result := {{ value['name'] }}({{ dobjectint }}(p{{ apidef.Prefix }}).{{ value['name'] }});
            {% endfor %} {#- FuncMap -#}
         {% endif %}
end;
     {%- else                       -%}
         {%- if value['type'] != 'funcptr' %}
procedure {{ value['name'] }}Set(p{{ apidef.Prefix }}: pointer; const x: {{ DType(pvalue['type']) }}); stdcall;
         {%- else                         -%}
            {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
            {%- for fmkey,fmvalue in funcmap[funcmap['fpos'] == 'p'].iterrows() %}
procedure {{ value['name'] }}Set(p{{ apidef.Prefix }}: pointer; const x: {{ value['name'] }}); stdcall;
            {% endfor %} {#- FuncMap -#}
         {%- endif %}
begin
{{ dobjectint }}(p{{ apidef.Prefix }}).{{ value['name'] }} := x;
end;
      {%- endif %}

   {%- endfor -%} {#- pn #}
{%- endfor -%} {#- tprop -#}
{%- endif -%} {#- apidef.dcx == 'dcex' #}

initialization

{%- if apidef.dcx in ['dc','dcex'] %}

libMutex := TStdMutex.Create;
objMutex := TStdMutex.Create;
exceptMutex := TStdMutex.Create;
Libhandle := nil;
{%- endif -%} {# apidef.dcx in ['dc','dcex'] #}
{%- if apidef.dcx == 'dcp' %}

Libhandle := 0;
{%- endif -%} {# apidef.dcx == 'dcp' #}
{%- if apidef.dcx != 'dp' %}
XLibraryUnload;

finalization
{%- if apidef.dcx in ['dc','dcex'] %}
{{ apidef.Prefix }}CloseDown();
{%- endif -%} {# apidef.dcx in ['dc','dcex'] #}
{%- endif -%} {# apidef.dcx == 'dp' #}

end.
{% endblock %}
