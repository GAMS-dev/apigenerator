{%- extends "delphibase.template.j2" -%}

{%- block header -%}
library {{ apidef.DelphiLib }};
{ Delphi Library program {{ api.generatedstr }} }
{% endblock -%}

{%- block content %}
{$P- no open parameters ==> no maxlen byte}
{$V+ force var strings}

uses
   {$I p3compat},
   gmsgen,
   pchutil
{%- for pre in apidef.pre.elements['prefix'].tolist() %}
{%- set dunit  = apidef.DUnit.elements[apidef.DUnit.elements['prefix']==pre] -%}
{%- if dunit.shape[0] > 0 -%} ,
   {{ dunit['text'].iloc[0] }}
{%- endif %}
{%- if apidef.ExtraUse.elements.shape[0] > 0 -%}
{%- for key,value in apidef.ExtraUse.elements[apidef.ExtraUse.elements['prefix']==pre].iterrows() -%} ,
   {{ value['text'] }}
{%- endfor %}
{%- endif %}
{%- endfor %};

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set prexfix = prexfix(pre)       -%}
   {%- set dunit   = dunit(pre)         -%}
   {%- set prefix  = prefix(pre)        -%}
   {%- set dobjectint = dobjectint(pre) -%}
   {%- set usecd = false -%}
   {%- if apidef.UseCD.elements.shape[0] > 0 -%}
     {%- if apidef.UseCD.elements[apidef.UseCD.elements['prefix']==pre].shape[0] > 0 -%} {%- set usecd = true -%}
     {%- endif -%}
   {%- endif %}

procedure {{ prexfix }}Create(var p{{ prefix }}: pointer); stdcall;
var
   Msg: shortstring;
begin
p{{ prefix }} := {{ dunit }}.{{ dobjectint }}.create(Msg);
end;

   {%- if usecd %}

procedure {{ prexfix }}CreateD(var p{{ prefix }}: pointer; const sysDir: shortString); stdcall;
var
   Msg: shortstring;
begin
p{{ prefix }} := {{ dunit  }}.{{ dobjectint  }}.created(sysDir, Msg);
end;

procedure C{{ prexfix }}CreateD(var p{{ prefix }}: pointer; const sysDir: pAnsiChar); stdcall;
var
   Msg: shortstring;
begin
p{{ prefix }} := {{ dunit  }}.{{ dobjectint  }}.created(PCharToStr(sysDir), Msg);
end;
   {%- endif %}
{%- endfor %}

function checkP(p: pointer; msgBuf: pAnsiChar; msgBufLen: Integer): Integer; stdcall;
begin
if nil = p
then
   begin
   StrPCopyN(msgBuf, 'Error while creating object', msgBufLen);
   Result := 0;
   end
else
   begin
   PAnsiCharArray(msgBuf)[0] := #0;
   Result := 1;
   end;
end;

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set prefix  = prefix(pre)  -%}
   {%- set prexfix = prexfix(pre) -%}
   {%- set usecd = false -%}
   {%- if apidef.UseCD.elements.shape[0] > 0 -%}
     {%- if apidef.UseCD.elements[apidef.UseCD.elements['prefix']==pre].shape[0] > 0 -%} {%- set usecd = true -%}
     {%- endif -%}
   {%- endif %}

function {{ prefix }}Create(var p{{ prefix }}: pointer; msgBuf: pAnsiChar; msgBufLen: Integer): Integer; stdcall;
begin
{{ prexfix }}Create (p{{ prefix }});
Result := checkP(p{{ prefix }}, msgBuf, msgBufLen);
end;

   {%- if usecd  %}

function {{ prefix }}CreateD(var p{{ prefix }}: pointer; const sysDir: shortString; msgBuf: pAnsiChar; msgBufLen: Integer): Integer; stdcall;
begin
{{ prexfix }}CreateD (p{{ prefix }}, sysDir);
Result := checkP(p{{ prefix }}, msgBuf, msgBufLen);
end;

function C{{ prefix }}CreateD(var p{{ prefix }}: pointer; const sysDir: pAnsiChar; msgBuf: pAnsiChar; msgBufLen: Integer): Integer; stdcall;
begin
{{ prexfix }}CreateD (p{{ prefix }}, PCharToStr(sysDir));
Result := checkP(p{{ prefix }}, msgBuf, msgBufLen);
end;
   {%- endif %}
{%- endfor %}

{%- for pre in apidef.pre.elements['prefix'].tolist() if not apidef.multi -%}
   {%- set usecd = false -%}
   {%- if apidef.UseCD.elements.shape[0] > 0 -%}
     {%- if apidef.UseCD.elements[apidef.UseCD.elements['prefix']==pre].shape[0] > 0 -%} {%- set usecd = true -%}
     {%- endif -%}
   {%- endif -%}
   {%- set prefix  = prefix(pre)  -%}
   {%- set prexfix = prexfix(pre)  %}
procedure {{ prefix }}{{ prexfix }}Create(var p{{ prefix }}: pointer); stdcall;
begin
{{ prexfix }}Create(p{{ prefix }});
end;

   {%- if usecd %}
procedure {{ prefix }}{{ prexfix }}CreateD(var p{{ prefix }}: pointer; const sysDir: shortString); stdcall;
begin
{{ prexfix }}CreateD(p{{ prefix }}, sysDir);
end;

procedure C{{ prefix }}{{ prexfix }}CreateD(var p{{ prefix }}: pointer; const sysDir: pAnsiChar); stdcall;
begin
{{ prexfix }}CreateD(p{{ prefix }}, PCharToStr(sysDir));
end;

   {%- endif %}
{% endfor -%}

{%- for pre in apidef.pre.elements['prefix'].tolist()  %}
procedure {{ prexfix(pre) }}Free (var p{{ prefix(pre) }}: pointer); stdcall;
begin
if p{{ prefix(pre) }} <> nil
then
   begin
   {{ dobjectint(pre) }}(p{{ prefix(pre) }}).Free;
   p{{ prefix(pre) }} := nil;
   end;
end;

{% endfor -%}

{% for pre in apidef.pre.elements['prefix'].tolist() -%}
function {{ prefix(pre) }}Free(var p{{ prefix(pre) }}: pointer): Integer; stdcall;
begin
   {{ prexfix(pre) }}Free (p{{ prefix(pre) }});
   if nil = p{{ prefix(pre) }}
   then
      Result := 1
   else
      Result := 0;
end;

{% endfor -%}

{%- for pre in apidef.pre.elements['prefix'].tolist() if not apidef.multi %}
procedure {{ prefix(pre) }}{{ prexfix(pre) }}Free(var p{{ prefix(pre) }}: pointer); stdcall;
begin
{{ prexfix(pre) }}Free(p{{ prefix(pre) }});
end;

{%- endfor %}

//comp returns the compatibility mode:
//0: client is too old for the DLL, no compatibility
//1: client version and DLL version are the same, full compatibility
//2: client is older than DLL, but defined as compatible, backward compatibility
//3: client is newer than DLL, forward compatibility
{% for pre in apidef.pre.elements['prefix'].tolist() -%}
function {{ prexfix(pre) }}APIVersion(const api: integer; var Msg: ShortString; var comp: Integer): Integer; stdcall;
begin
   result := 0;
   comp   := 0;
   {%- for rv in apidef.RecentVersion.elements[apidef.RecentVersion.elements['prefix']==pre]['rv'].tolist() %}
   Msg    := '{{ apidef.DelphiLib }}: The API is too old for the used library, API version: ' + inttostr(api) + ', library version: {{ rv }}';
   if api >= {{ rv }}
   then
      begin
      result := 1;
      if api = {{ rv }}
      then
         begin
         comp := 1;
         Msg  := '{{ apidef.DelphiLib }}: API version and library version are the same.';
         end
      else
         begin
         comp := 3;
         Msg  := '{{ apidef.DelphiLib }}: API version is newer than this library.';
         end;
      exit;
      end;
   if (
      {%- set counter = namespace(value=0) -%}
      {%- for cv in apidef.Version.elements[apidef.Version.elements['prefix']==pre]['cv'].tolist() %}
        {%- if counter.value == 0 -%} (api = {{ cv }})
        {%- else                   %} or (api = {{ cv }})
        {%- endif -%}
        {%- set counter.value = counter.value + 1 -%}
      {%- endfor -%}
)
   then
      begin
      result := 1;
      comp   := 2;
      Msg    := '{{ apidef.DelphiLib }}: Client version is compatible to this version of the library.';
      exit;
      end;
end;
   {%- endfor %}

function C{{ prexfix(pre) }}APIVersion(const api: integer; Msg: pAnsiChar; var comp: Integer): Integer; stdcall;
var local_Msg: ShortString;
begin
result := {{ prexfix(pre) }}APIVersion(api, local_Msg, comp);
StrPCopy(Msg, local_Msg);
end;

{% endfor -%} {#- pre -#}

{%- for pre in apidef.pre.elements['prefix'].tolist() if not apidef.multi %}
function {{ prefix(pre) }}{{ prexfix(pre) }}APIVersion(const api: integer; var Msg: ShortString; var comp: Integer): Integer; stdcall;
begin
result := {{ prexfix(pre) }}APIVersion(api, Msg, comp);
end;

{% endfor -%} {#- pre #}

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set entmp = apidef.enp.elements[apidef.enp.elements['prefix']==pre]['element'].tolist() -%}
function {{ prexfix(pre) }}Check(const funcn: shortString; const ClNrArg: integer; const Clsign: PIntegerArray; var Msg: ShortString): Integer; stdcall;
var   i,EntryIndex: Integer;
const maxarg   = {{ apidef.fargmax['value'] }};
   {%- set maxentry = namespace(value=0) -%}
   {%- for key,value in apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(entmp)].iterrows() -%}
      {%- set maxentry.value = maxentry.value + 1 -%}
   {% endfor -%} {# apidef.tfunc -#}
   {% for key,value in apidef.pn.elements[apidef.pn.elements['name'].isin(entmp)].iterrows() -%}
      {%- set maxentry.value = maxentry.value + 1 -%}
   {%- endfor -%} {# apidef.tfunc #}
const maxentry = {{ maxentry.value }};
const maxlen   = {{ apidef['idlenWset']['value'] }};

const EntryName: array[1..maxentry] of string[maxlen] = (
{%- set counter = namespace(argpos=1) -%}
{%- set tfunc   = apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(entmp)] -%}
{%- for key,value in tfunc.iterrows() %}
      '{{ value['name'] }}'
    {%- if counter.argpos < maxentry.value -%} , {%- endif -%}
    {%- set counter.argpos = counter.argpos + 1    -%}
{% endfor -%} {#- tfunc -#}
{%- set pn = apidef.pn.elements[apidef.pn.elements['name'].isin(entmp)] -%}
{%- for key,value in pn.iterrows() %}
      '{{ value['name'] }}
    {%- if value['pactions'] == 'w' -%} Set {%-endif -%}
      '
    {%- if counter.argpos < maxentry.value -%}, {%- endif -%}
    {%- set counter.argpos = counter.argpos + 1   -%}
{% endfor -%} {#- pn -#}
);

const DLLNrArg: array[1..maxentry] of integer = (
      {% set counter = namespace(argpos=1) -%}
{%- for key,value in tfunc.iterrows() -%}
    {%- set farg = apidef.farg.elements.loc[apidef.farg.elements['name']==value['name']] -%}
    {%- if farg.shape[0] > 0 -%} {{ farg['value'].iloc[0] }}
    {%- else                 -%} 0
    {%- endif -%}
    {%- if counter.argpos < maxentry.value -%}, {%- endif -%}
    {%- set counter.argpos = counter.argpos + 1 -%}
{% endfor -%} {# tfunc -#}
{%- for key,value in pn.iterrows() -%}
    {%- if value['pactions'] == 'w' -%} 1
    {%- else                        -%} 0
    {%- endif -%}
    {%- if counter.argpos < maxentry.value -%}, {%- endif -%}
    {%- set counter.argpos = counter.argpos + 1           -%}
{% endfor -%} {# pn -#} 
);

const DLLsign: array[1..maxentry,0..maxarg] of integer = (
      {%- set tpp  = datadef.tpp.elements['tp'] %}
{%- set entry = namespace(pos=1) -%}
{%- for key,value in tfunc.iterrows() %}
      ({{ taind(value['type']) }},
    {%- set counter = namespace(value=1) -%}
    {%- set f = apidef.f.elements[apidef.f.elements['name']==value['name']]   -%}
    {%- for fkey,fvalue in f[f['pos'].isin(tpp)].iterrows() if f.shape[0] > 0 -%}
       {{ taind(fvalue['type']) }}
       {%- if counter.value < apidef.fargmax['value'] -%}, {%- endif -%}
       {%- set counter.value  = counter.value  + 1 -%}
    {% endfor -%} {# apidef.f -#}
    {%- for i in range(counter.value, apidef.fargmax['value']+1) -%}
       -1 {%- if i < apidef.fargmax['value'] -%}, {%- endif -%}
    {%- endfor -%}
    )
    {%- if entry.pos < maxentry.value -%}, {%- endif -%}
    {%- set entry.pos = entry.pos + 1                      -%}
{%- endfor -%} {#- apidef.tfunc -#}
{%- for key,value in pn.iterrows() -%}
    {%- if value['pactions'] == 'w' %}
      ({{ taind('void') }},{{ taind(value['type']) }}
      {%- for i in range(2, apidef.fargmax['value']+1) -%}
        ,-1
      {%- endfor -%}
    {%- else                        %}
      ({{ taind(value['type']) }}
      {%- for i in range(1, apidef.fargmax['value']+1) -%}
        ,-1
      {%- endfor -%}
    {%- endif -%}
    )
    {%- if entry.pos < maxentry.value -%}, {%- endif -%}
    {%- set entry.pos = entry.pos + 1                      -%}
{%- endfor -%} {# pn -#}
);

begin
EntryIndex := 0;
for i := 1 to maxentry
do if EntryName[i] = funcn
   then
      begin
      EntryIndex := i;
      break;
      end;

if EntryIndex=0
then
   begin
   result := 0;
   msg    := '{{ apidef.DelphiLib }}: ' + funcn + ' cannot be found in the library.';
   exit;
   end;

result := 1;
Msg    := '';
if DLLNrArg[EntryIndex] <> ClNrArg
then
   begin
   result := 0;
   Msg    := '{{ apidef.DelphiLib }}: ' + funcn + ' has wrong number of arguments, the API expects ' + inttostr(ClNrArg) + ' but it has ' + inttostr(DLLNrArg[EntryIndex]) + ' in the library.';
   end
else
   for i := 0 to DLLNrArg[EntryIndex]
   do if DLLsign[EntryIndex,i] <> Clsign^[i]
      then
         begin
         result := 0;
         if Msg = '' then Msg := '{{ apidef.DelphiLib }}: ' + funcn + ' has wrong argument type for argument ' + inttostr(i)
         else             Msg := Msg + ',' + inttostr(i);
         end;
end;

function C{{ prexfix(pre) }}Check(const funcn: pAnsiChar; const ClNrArg: integer; const Clsign: PIntegerArray; Msg: pAnsiChar): Integer; stdcall;
var local_Msg: ShortString;
begin
result := {{ prexfix(pre) }}Check(PCharToStr(funcn), ClNrArg, Clsign, local_Msg);
StrPCopy(Msg, local_Msg);
end;
{% endfor -%}

{%- for pre in apidef.pre.elements['prefix'].tolist() if not apidef.multi %}
function {{ prefix(pre) }}{{ prexfix(pre) }}Check(const funcn: shortString; const ClNrArg: integer; const Clsign: PIntegerArray; var Msg: ShortString): Integer; stdcall;
begin
result := {{ prexfix(pre) }}Check(funcn, ClNrArg, Clsign, Msg);
end;
{% endfor -%}

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set pretext = prefix(pre) -%}
   {%- if apidef.ulp.elements.shape[0] > 0  -%}
     {%- set ulp = apidef.ulp.elements[apidef.ulp.elements['prefix'] == pre]                      -%}
     {%- set dunit   = apidef.DUnit.elements[apidef.DUnit.elements['prefix']==pre]['text'].iloc[0] %}
procedure {{ pretext }}SetLoadPath (const s: shortString); stdcall;
begin
   {{ dunit }}.DLLLoadPath := s;
end;

procedure C{{ pretext }}SetLoadPath (ps: pAnsiChar); stdcall;
begin
   {{ pretext }}SetLoadPath(PCharToStr(ps));
end;

procedure {{ pretext }}GetLoadPath (var s: shortString); stdcall;
begin
   s := {{ dunit }}.DLLLoadPath;
end;

procedure C{{ pretext }}GetLoadPath (ps: pAnsiChar); stdcall;
var
   s: ShortString;
begin
   {{ pretext }}GetLoadPath(s);
   StrPCopy(ps, s);
end;
   {%- endif %}
{%- endfor -%}

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set prefix     = prefix(pre)     -%}
   {%- set dobjectint = dobjectint(pre) -%}
   {%- set entmp = apidef.enp.elements[apidef.enp.elements['prefix']==pre]['element'].tolist()    -%}
   {%- set tfunc   = apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(entmp)]             -%}
   {%- for key,value in tfunc.iterrows() -%}
      {%- if value['type'] == 'void' or value['type'] == 'oss' %}
{{ functionsDescription(value['text']) }}
procedure
      {%- else                                                 %}
{{ functionsDescription(value['text']) }}
function
      {%- endif %} {{ value['name'] }}(p{{ prefix }}: pointer
      {%- set tpp  = datadef.tpp.elements['tp']                                  -%}
      {%- set f    = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
      {%- set ftpp = f[f['pos'].isin(tpp)]                                       -%}
      {%- set counter = namespace(fpos=1)                                         -%}
      {%- if ftpp.shape[0] > 0 -%}; {% endif -%}
      {%- for fkey,fvalue in ftpp.iterrows() -%}
         {%- if fvalue['type'] == 'funcptr' and apidef.FuncMap.elements.shape[0] > 0 -%}
            {%- set fm       = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
            {%- set fmargpos = 1                                                                      -%}
            {%- for fmkey,fmvalue in fm.iterrows() -%}
{{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name']}}
               {%- if fmargpos < fm.shape[0] -%}; {% endif -%}
               {%- set fmargpos = fmargpos + 1                  -%}
            {%- endfor %}
         {%- elif fvalue['type'] in ['bool', 'vbool']                               -%}
{{ DCall(fvalue['type'])}}{{ fvalue['arg'] }}: Integer
         {%- else                                     -%}
{{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
         {%- endif -%}
         {%- if counter.fpos < ftpp.shape[0] -%}; {% endif -%}
         {%- set counter.fpos = counter.fpos + 1           -%}
      {% endfor -%} {# apidef.f -#}
      {%- if value['type'] == 'oss' -%}; var sst_result: ShortString {%- endif -%}
)
      {%- if value['type'] in ['void', 'oss'] -%}; stdcall;
      {%- elif value['type'] == 'funcptr'     -%}
         {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
         {%- for fmkey,fmvalue in funcmap.iterrows() -%}
: {{ fmvalue['name'] }}; stdcall;
         {%- endfor %}
      {%- elif value['type'] == 'bool'        -%}: Integer; stdcall;
      {%- else                                -%}: {{ DType(value['type']) }}; stdcall;
      {%- endif %}
      {%- if apidef.doc %}
// Arguments:
//   p{{ pre }}: Pointer to {{ pre.upper() }} structure
// Note: This is the Delphi wrapped version of <LINK {{ dobjectint }}.{{ value['name'] }}>
      {%- endif %}
      {%- set fvbool  = ftpp[ftpp['type'] == 'vbool'] -%}
      {%- if fvbool.shape[0] > 0 %}
var
     {%- endif %}
     {%- for fkey,fvalue in fvbool.iterrows() %}
   bb_{{ fvalue['arg'] }} : Boolean;
     {%- endfor %}
begin
     {%- if apidef.trace %}
writeln(' TRACE {{ value['name'] }} BEG (
        {%- for fkey,fvalue in ftpp.iterrows() -%}
           {%- set delphiptr = datadef.DelphiPtr.elements.loc[datadef.DelphiPtr.elements['ta']==fvalue['type']]   -%}
           {%- set delphigdx = datadef.DelphiGDX.elements.loc[datadef.DelphiGDX.elements['ta']==fvalue['type']]   -%}
           {%- if fvalue['type'] == 'funcptr' -%}
              {%- set fm      = apidef.FuncMap.elements[apidef.FuncMap.elements['def'] == value['name']] -%}
              {%- for fmkey,fmvalue in fm[fm['fpos'].isin(tpp)].iterrows() if fm.shape[0] > 0 -%}
{{ fvalue['arg'] }}: {{ fmvalue['name']}};
              {%- endfor %}
           {%- elif delphigdx.shape[0] > 0    -%}
{{ delphigdx['text'].iloc[0] }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }};
           {%- else                           -%}
{{ fvalue['arg'] }}=',
              {%- if delphiptr.shape[0] >0 -%} integer( {%- endif -%}
{{ fvalue['arg'] }}
              {%- if delphiptr.shape[0] >0 -%} ) {%- endif -%}
      ,';
           {%- endif -%}
        {%- endfor -%}
)); flush(output);
     {%- endif %}
      {%- for fkey,fvalue in ftpp[ftpp['name'].isin(entmp)].iterrows() 
          if ftpp.shape[0] > 0 and apidef.PFtrF.elements.shape[0] > 0 and fvalue['type']=='funcptr' %}
         {%- set PFtrF  = apidef.PFtrF.elements['name'].tolist()                                  -%}
         {%- set fm     = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
         {%- if PFtrF|length > 0 and fm.shape[0] > 0 -%}
            {%- set fmpos = fm[fm['fpos']==fvalue['pos']] -%}
            {%- if fmpos.shape[0] > 0 %}
               {%- if fmpos[fmpos['name'].isin(PFtrF)].shape[0] > 0 %}
{{ dobjectint }}(p{{ pre }}).{{ fvalue['name'] }}_{{ fvalue['arg'] }}_CallByRef := false;
               {%- endif -%}
            {%- endif -%}
         {%- endif -%}
      {%- endfor -%}
     {#- endif #}
     {%- for fkey,fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
bb_{{ fvalue['arg'] }} := {{ fvalue['arg'] }} <> 0;
     {%- endfor %}
     {%- if value['type'] == 'oss'    %}
sst_result := {{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
     {%- elif value['type'] == 'bool' %}
result := Integer({{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
     {%- elif value['type'] != 'void' %}
result := {{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
     {%- else                         %}
{{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
     {%- endif  -%}
     {%- set farg = apidef.farg.elements.loc[apidef.farg.elements['name']==value['name']] -%}
     {%- if farg.shape[0] > 0 -%}
(
         {%- set counter = namespace(argpos=1) -%}
         {%- for fkey,fvalue in ftpp.iterrows() -%}
            {%- if fvalue['type'] == 'vbool' -%} bb_  {%- endif -%}
            {%- if fvalue['type'] == 'bool'  -%} 0 <> {%  endif -%}
{{ fvalue['arg'] }}
            {%- if counter.argpos < ftpp.shape[0] -%}, {% endif -%}
            {%- set counter.argpos = counter.argpos + 1         -%}
         {%- endfor -%}
)
     {%- endif -%}
     {%- if ((farg.shape[0] == 0) and (value['type']=='funcptr'))-%} () {%- endif -%}
     {%- if value['type']=='bool'                                -%} )  {%- endif -%}
;
     {%- for fkey, fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
{{ fvalue['arg'] }} := Integer(bb_{{ fvalue['arg'] }});
     {%- endfor -%}

     {%- if apidef.trace %}
writeln(' TRACE {{ value['name'] }} END (
         {%- for fkey,fvalue in ftpp.iterrows() -%}
            {%- set delphiptr  = datadef.DelphiPtr.elements.loc[datadef.DelphiPtr.elements['ta']==fvalue['type']]   -%}
            {%- set delphigdx  = datadef.DelphiGDX.elements.loc[datadef.DelphiGDX.elements['ta']==fvalue['type']]   -%}
            {%- if fvalue['type'] == 'funcptr' -%}
               {%- set fm      = apidef.FuncMap.elements[apidef.FuncMap.elements['def'] == value['name']] -%}
               {%- set funcmap = fm[fm['fpos'].isin(tpp)]                                            -%}
               {%- for fmkey,fmvalue in funcmap.iterrows() -%}
{{ fvalue['arg'] }}: {{ fmvalue['name']}};
               {%- endfor %}
            {%- elif delphigdx.shape[0] > 0    -%}
{{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }};
            {%- else                           -%}
{{ fvalue['arg'] }}=',
               {%- if delphiptr.shape[0] >0 -%} integer( {%- endif -%}
{{ fvalue['arg'] }}
               {%- if delphiptr.shape[0] >0 -%} ) {%- endif -%}
      ,';
            {%- endif -%}
            {%- if not fvalue['type'] == 'void' or (fvalue['type'] in ['oss','funcptr']) -%} result=', {%- endif -%}
            {%- if delphiptr.shape[0] > 0 -%} integer( {%- endif -%}
   result
            {%- if delphiptr.shape[0] > 0 -%} )  {%- endif -%}
   ,';
         {%- endfor -%}
)); flush(output);
     {%- endif %}
end;
   {%- endfor -%} {#- apidef.tfunc #}
{%- endfor -%} {# apidef.pre -#}

{#- *** now it gets ugly, do the same thing over again
    *** just to handle callbacks for Fortran clients
-#}
{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
{%- if apidef.fpf.elements.shape[0] > 0 -%}
   {%- set dobjectint = dobjectint(pre) -%}
   {%- set prefix  = prefix(pre)        -%}
   {%- set prexfix = prexfix(pre)       -%}
   {%- set entmp = apidef.enp.elements[apidef.enp.elements['prefix']==pre]['element'].tolist()    -%}
   {%- set fpfentmp = apidef.fpf.elements['def'][apidef.fpf.elements['def'].isin(entmp)].tolist() -%}
   {%- set tfunc    = apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(fpfentmp)]         -%}
   {%- for key,value in tfunc.iterrows() -%}
      {%- set PFtrF  = apidef.PFtrF.elements['name'].tolist()                                 -%}
      {%- set fm     = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- if PFtrF|length > 0 and fm.shape[0] > 0 and fm[fm['name'].isin(PFtrF)].shape[0] > 0 -%}
         {%- if value['type'] == 'void' %}
{{ functionsDescription(value['text']) }}
procedure
         {%- else                       %}
{{ functionsDescription(value['text']) }}
function
         {%- endif %} F{{ value['name'] }}(p{{ prefix }}: pointer
         {%- set tpp  = datadef.tpp.elements['tp']                                  -%}
         {%- set f    = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
         {%- set ftpp = f[f['pos'].isin(tpp)]                                       -%}
         {%- set counter = namespace(pos=1)                                         -%}
         {%- set fcounter = namespace(max=ftpp.shape[0])                            -%}
         {%- if ftpp.shape[0] > 0 -%}; {% endif -%}
         {%- for fkey,fvalue in ftpp.iterrows() -%}
            {%- if fvalue['type'] == 'funcptr'          -%}
               {%- set fmcounter = namespace(pos=1)                                                       -%}
               {%- for fmkey,fmvalue in fm.iterrows() -%}
                  {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}_F
                  {%- if fmcounter.pos < fm.shape[0]        -%}; {% endif -%}
                  {%- set fmcounter.pos = fmcounter.pos + 1 -%}
               {%- endfor -%}
            {%- elif fvalue['type'] in ['bool','vbool'] -%}
               {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: Integer
            {%- else                                    -%}
               {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
            {%-  endif -%}
            {%- if counter.pos < fcounter.max -%}; {% endif -%}
            {%- set counter.pos = counter.pos + 1           -%}
         {%- endfor -%} {#- ftpp -#}
         {%- if value['type'] == 'oss' -%}; sst_resultBuf: pAnsiChar {%- endif -%}
)
         {%- if value['type'] == 'void'      -%}; stdcall;
         {%- elif value['type'] == 'funcptr' -%}
            {%- for fmkey,fmvalue in fm.iterrows() -%}
              : {{ fmvalue['name'] }}_F; stdcall;
            {%- endfor %}
         {%- elif value['type'] == 'bool'    -%}: Integer; stdcall;
         {%- elif value['type'] == 'os'      -%}: pAnsiChar; stdcall;
         {%- else                            -%}: {{ DType(value['type']) }}; stdcall;
         {%- endif -%}
         {%- if apidef.doc %}
// Arguments:
//   p{{ pre }}: Pointer to {{ pre.upper() }} structure
// Note: This is the Delphi wrapped version of <LINK {{ dobjectint }}.{{ value['name'] }}>
         {%- endif %}
         {%- if ftpp.shape[0] > 0 -%}
            {%- if ftpp[ftpp['type'].isin(['funcptr','vbool','oss'])].shape[0] > 0 %}
var
            {%-  endif -%}
         {%-  endif -%}
         {%- if value['type'] in  'oss' %}   local_sst_result : shortstring;
         {%- endif -%}
         {%- for fkey,fvalue in ftpp[ftpp['type']=='funcptr'].iterrows() %}
            {%- for fmkey,fmvalue in fm.iterrows() %}
   local_{{ fvalue['arg'] }} : {{ fmvalue['name'] }};
            {%- endfor -%}
         {%- endfor -%} {#- ftpp -#}
         {%- for fkey,fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
   bb_{{ fvalue['arg'] }} : Boolean;
         {%- endfor -%} {#- ftpp #}
begin
         {%- for fkey,fvalue in ftpp[ftpp['type']=='funcptr'].iterrows() %}
{{ dobjectint }}(p{{ prefix }}).{{ fvalue['name'] }}_{{ fvalue['arg'] }}_CallByRef := true;
         {%- endfor -%} {#- ftpp #}
         {%- for fkey,fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
bb_{{ fvalue['arg'] }} := {{ fvalue['arg'] }} <> 0;
         {%- endfor -%} {#- ftpp -#}
         {%- for fkey,fvalue in ftpp[ftpp['type']=='funcptr'].iterrows() %}
@local_{{ fvalue['arg'] }} := @{{ fvalue['arg'] }};
         {%- endfor -%} {#- ftpp #}
{# -#}
         {%- if value['type'] == 'oss'     -%} local_sst_ {%- endif -%}
         {%- if value['type'] != 'void'    -%} result := {% endif -%}
         {%- if value['type'] == 'bool'    -%} Integer(  {%- endif -%}
         {%- if value['type'] == 'funcptr' -%}
            {%- for fmkey,fmvalue in fm.iterrows() -%}
{{ fmvalue['name'] }}_F(
            {%- endfor -%}
         {%- endif -%} {{ dobjectint }}(p{{ prefix }}).{{ value['name']}}
         {%- set farg = apidef.farg.elements.loc[apidef.farg.elements['name']==value['name']] -%}
         {%- if farg.shape[0] > 0 -%} (
            {%- set counter = namespace(ftpppos = 1) -%}
            {%- for fkey,fvalue in ftpp.iterrows() -%}
               {%- if fvalue['type'] == 'funcptr' -%} local_ {%- endif -%}
               {%- if fvalue['type'] == 'vbool'   -%} bb_    {%- endif -%}
               {%- if fvalue['type'] == 'bool'    -%} 0 <> {% endif    -%}
{{ fvalue['arg'] }}
               {%- if counter.ftpppos < ftpp.shape[0] -%}, {% endif -%}
               {%- set counter.ftpppos = counter.ftpppos + 1        -%}
            {%- endfor -%} {#- ftpp -#}
)
         {%- endif -%}
         {%- if value['type'] == 'funcptr'          -%} () {%- endif -%}
         {%- if value['type'] in ['funcptr','bool'] -%} )  {%- endif -%}
;
         {%- for fkey,fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
{{ fvalue['arg'] }} := Integer(b_{{ fvalue['arg'] }});
         {%- endfor -%} {#- ftpp -#}
         {%- if value['type'] == 'oss' %}
result := StrPCopy(sst_resultBuf, local_sst_result);
         {%- endif %}
end;
      {%- endif %}
   {%- endfor -%} {# apidef.tfunc #}
{%- endif -%}
{%- endfor -%} {#- apidef.pre -#}

{#- *** now it gets ugly, do the same thing over again
    *** just to handle CSS, oSS and xSS into pAnsiChar, as well cSI and oSI
#}

{%- set enstring   = apidef.enstring.elements['name'].tolist()                           -%}
{%- set tfenstring = apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(enstring)] -%}
{%- if tfenstring.shape[0] > 0 %}

{ --- Entry points having string arguments }
{%- endif %}

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set dobjectint = dobjectint(pre) -%}
   {%- set prefix     = prefix(pre)     -%}
   {%- set prexfix    = prexfix(pre)    -%}
   {%- set MaxDimStyle = '' -%}
   {%- if ((apidef.MaxDimStyle is defined) and (apidef.MaxDimStyle.elements.shape[0] > 0)) -%}
      {%- set mds = apidef.MaxDimStyle.elements[apidef.MaxDimStyle.elements['prefix']==pre] -%}
      {%- if mds.shape[0] > 0 -%}
          {%- set MaxDimStyle = mds['prefix'].iloc[0] -%}
      {%- endif -%}
   {%- endif -%}
   {%- set entmp = apidef.enp.elements[apidef.enp.elements['prefix']==pre]['element'].tolist()                   -%}
   {%- set enstrentmp = apidef.enstring.elements[apidef.enstring.elements['name'].isin(entmp)]['name'].tolist()  -%}
   {%- for key,value in apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(enstrentmp)].iterrows() -%}
      {%- if value['type'] == 'void' %}
{{ functionsDescription(value['text']) }}
procedure
      {%- else                       %}
{{ functionsDescription(value['text']) }}
function
      {%- endif %} C{{ value['name'] }}(p{{ prefix }}: pointer
      {%- set tpp  = datadef.tpp.elements['tp']                                  -%}
      {%- set f    = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
      {%- set ftpp = f[f['pos'].isin(tpp)]                                       -%}
      {%- set counter = namespace(pos=1)                                         -%}
      {%- set fcounter = namespace(max=ftpp.shape[0])                            -%}
      {%- if ftpp.shape[0] > 0 -%}; {% endif -%}
      {%- for fkey,fvalue in ftpp.iterrows() -%}
         {%- set tass  = datadef.tass.elements.loc[datadef.tass.elements['ta']==fvalue['type']] -%}
         {%- if tass.shape[0] > 0 -%}
            {{ DCallC(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DTypeC(fvalue['type']) }}
            {%- if fvalue['type'] == 'xss'-%}
               ; const {{ fvalue['arg'] }}_i: Integer
            {%-  endif -%}
         {%- else                 -%}
            {%- if fvalue['type'] == 'funcptr'           -%}
               {%- set fm      = apidef.FuncMap.elements[apidef.FuncMap.elements['def'] == value['name']] -%}
               {%- set fmcounter = namespace(pos=1)                                                       -%}
               {%- for fmkey,fmvalue in fm.iterrows() -%}
                  {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
                  {%- if fmcounter.pos < fm.shape[0]        -%}; {% endif -%}
                  {%- set fmcounter.pos = fmcounter.pos + 1 -%}
               {%- endfor -%}
            {%- elif fvalue['type'] in ['bool', 'vbool'] -%}
               {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: Integer
            {%- else                                     -%}
               {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
            {%-  endif -%}
         {%-  endif -%}
         {%- if counter.pos < fcounter.max -%}; {% endif -%}
         {%- set counter.pos = counter.pos + 1           -%}
      {%- endfor -%} {#- ftpp -#}
      {%- if value['type'] == 'oss' -%}; sst_resultBuf: pAnsiChar {%- endif -%}
)
      {%- if value['type'] != 'void'       -%}
         {%- if value['type'] == 'funcptr' -%}
            {%- set funcmap = apidef.FuncMap.elements[apidef.FuncMap.elements['def'].isin(entmp)] -%}
            {%- for fmkey,fmvalue in funcmap.iterrows() -%}
               : {{ fmvalue['name'] }}
            {%- endfor -%}
         {%- elif value['type'] == 'bool'  -%} : Integer
         {%- elif value['type'] == 'oss'   -%} : pAnsiChar
         {%- else                          -%} : {{ DType(value['type']) }}
         {%- endif %}
      {%- endif -%}
; stdcall;
      {%- if apidef.doc %}
// Arguments:
//   p{{ pre }}: Pointer to {{ pre.upper() }} structure
// Note: This is the C wrapped version of <LINK {{ dobjectint }}.{{ value['name'] }}>
      {%- endif %}
      {%- if value['type'] == 'oss' %}
var local_sst_result : shortstring;
      {%- endif %}
      {%- for fkey,fvalue in ftpp.iterrows() -%}
         {%- if fvalue['type'] in ['oss', 'xss']  %}
var local_{{ fvalue['arg'] }}: Shortstring;
      {%- elif fvalue['type'] in ['osi','csi']    %}
var {{ fvalue['arg'] }}_i : integer;
    {{ fvalue['arg'] }}_s : TgdxStrIndex;
         {%-  endif -%}
      {%- endfor -%} {#- ftpp -#}
      {%- set ftppvbool = ftpp[ftpp['type']=='vbool'] -%}
      {%- if ftppvbool.shape[0] > 0 %}
var
      {%- endif -%}
      {%- for fkey,fvalue in ftppvbool.iterrows() %}
   bb_{{ fvalue['arg'] }} : Boolean;
      {%- endfor -%} {#- ftpp #}
begin
{#- newline #}
{%- if apidef.trace %}
writeln(' TRACE {{ value['name'] }} BEG (
{%- for fkey,fvalue in ftpp.iterrows() -%}
   {%- set delphiptr = datadef.DelphiPtr.elements.loc[datadef.DelphiPtr.elements['ta']==fvalue['type']]   -%}
   {%- set delphigdx = datadef.DelphiGDX.elements.loc[datadef.DelphiGDX.elements['ta']==fvalue['type']]   -%}
   {%- if fvalue['type'] == 'funcptr' -%}
      {%- set fm      = apidef.FuncMap.elements[apidef.FuncMap.elements['def'] == value['name']] -%}
      {%- for fmkey,fmvalue in fm[fm['fpos'].isin(tpp)].iterrows() if fm.shapep[0] > 0 -%}
         {{ fvalue['arg'] }}: {{ fmvalue['name']}};
      {%- endfor %}
   {%- elif delphigdx.shape[0] > 0    -%}
      {{ delphigdx['text'].iloc[0] }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }};
   {%- else                           -%}
      {{ fvalue['arg'] }}=',
      {%- if delphiptr.shape[0] >0 -%} integer( {%- endif -%}
      {{ fvalue['arg'] }}
      {%- if delphiptr.shape[0] >0 -%} ) {%- endif -%}
      ,';
   {%- endif -%}
{%- endfor -%}
)); flush(output);
{%- endif -%}
      {%- for fkey,fvalue in ftpp[ftpp['name'].isin(entmp)].iterrows() if fvalue['type']=='funcptr' -%}
         {%- set PFtrF  = apidef.PFtrF.elements['name'].tolist()                                  -%}
         {%- set fm     = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
         {%- if PFtrF|length > 0 and fm.shape[0] > 0    -%}
            {%- set fmpos = fm[fm['fpos']==fvalue['pos']] -%}
            {%- if fmpos.shape[0] > 0 -%}
               {%- if fmpos[fmpos['name'].isin(PFtrF)].shape[0] > 0 %}
{{ dobjectint }}(p{{prefix }}).{{ fvalue['name'] }}_{{ fvalue['arg'] }}_CallByRef := false;
               {%- endif -%}
            {%- endif -%}
         {%- endif -%}
      {% endfor -%}
      {%- for fkey,fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
bb_{{ fvalue['arg'] }} := {{ fvalue['arg'] }} <> 0;
{#- newline -#}
      {%- endfor -%} {#- ftpp -#}
      {%- for fkey,fvalue in ftpp[ftpp['type']=='csi'].iterrows() -%}
         {%- if ((apidef.callSymbolDim is defined) and (apidef.callSymbolDim.elements.shape[0] > 0)) -%}
            {%- set callsymboldim = apidef.callSymbolDim.elements[apidef.callSymbolDim.elements['name']==value['name']] -%}
            {%- if callsymboldim.shape[0] > 0 and fvalue['name'] in callsymboldim['name'].tolist() %}
for {{ fvalue['arg'] }}_i := 1 to {{ callsymboldim['dimension'].iloc[0] }}
            {%- else                                          %}
for {{ fvalue['arg'] }}_i := 1 to {% if mds is defined and mds.shape[0] > 0 and 'gdx' in mds['prefix'].tolist() -%} TGXFileObj(p{{ prefix }}).GDXDimension{%- else -%} Maxdim {%- endif -%}
            {%- endif -%}
         {%- else                                          %}
for {{ fvalue['arg'] }}_i := 1 to {% if mds is defined and mds.shape[0] > 0 and 'gdx' in mds['prefix'].tolist() -%} TGXFileObj(p{{ prefix }}).GDXDimension{%- else -%} Maxdim {%- endif -%}
         {%- endif %}
do {{ fvalue['arg'] }}_s[{{ fvalue['arg'] }}_i] := PCharToStr(pAnsiChar({{ fvalue['arg'] }}^[{{ fvalue['arg'] }}_i-1]));
      {%- endfor -%} {#- ftpp #}
      {%- if value['type'] == 'oss'    %}
local_sst_result := {{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
      {%- elif value['type'] == 'bool' %}
result := Integer({{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
      {%- elif value['type'] != 'void' %}
result := {{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
      {%- else                         %}
{{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
      {%- endif  -%}
      {%- set farg = apidef.farg.elements.loc[apidef.farg.elements['name']==value['name']] -%}
      {%- if farg.shape[0] > 0 -%} (
         {%- set counter = namespace(ftpppos = 1) -%}
         {%- for fkey,fvalue in ftpp.iterrows() -%}
            {%- if fvalue['type'] == 'css'           -%} PCharToStr({{ fvalue['arg'] }})
            {%- elif fvalue['type'] in ['oss','xss'] -%} local_{{ fvalue['arg'] }}
            {%- elif fvalue['type'] in ['csi','osi'] -%} {{ fvalue['arg'] }}_s
            {%- elif fvalue['type'] == 'vbool'       -%} bb_{{ fvalue['arg'] }}
            {%- elif fvalue['type'] == 'bool'        -%} 0 <> {{ fvalue['arg'] }}
            {%- else                                 -%} {{ fvalue['arg'] }}
            {%- endif -%}
            {%- if counter.ftpppos < ftpp.shape[0] -%}, {% endif -%}
            {%- set counter.ftpppos = counter.ftpppos + 1        -%}
         {%- endfor -%} {#- ftpp -#}
)
         {%- if value['type'] == 'bool' -%} ) {%- endif -%}
      {%- endif -%}
;
      {%- for fkey,fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
{{ fvalue['arg'] }} := Integer(bb_{{ fvalue['arg'] }});
      {%- endfor -%} {#- ftpp -#}
      {%- for fkey,fvalue in ftpp.iterrows() -%}
         {%- if fvalue['type'] == 'oss'    %}
StrPCopy({{ fvalue['arg'] }}, local_{{ fvalue['arg'] }});
         {%- elif fvalue['type'] == 'xss'  %}
StrPCopyN({{ fvalue['arg'] }}, local_{{ fvalue['arg'] }}, {{ fvalue['arg'] }}_i);
         {%- elif fvalue['type'] == 'osi' -%}
            {%- if MaxDimStyle == 'gdx' %}
if result <> 0
then
            {%- endif -%} {#- MaxDimStyle -#}
            {%- if ((apidef.callSymbolDim is defined) and (apidef.callSymbolDim.elements.shape[0] > 0)) -%}
               {%- set callsymboldim = apidef.callSymbolDim.elements[apidef.callSymbolDim.elements['name']==value['name']] -%}
               {%- if callsymboldim.shape[0] > 0 and fvalue['name'] in callsymboldim['name'].tolist() %}
   for {{ fvalue['arg'] }}_i := 1 to {{ callsymboldim['dimension'].iloc[0] }}
               {%- else                                                                               %}
   for {{ fvalue['arg'] }}_i := 1 to {% if mds is defined and mds.shape[0] > 0 and 'gdx' in mds['prefix'].tolist() -%} TGXFileObj(p{{ prefix }}).GDXDimension {%- else -%} Maxdim {%- endif -%}
               {%- endif -%} 
            {%- else                                                                                  %}
   for {{ fvalue['arg'] }}_i := 1 to {% if mds is defined and mds.shape[0] > 0 and 'gdx' in mds['prefix'].tolist() -%} TGXFileObj(p{{ prefix }}).GDXDimension {%- else -%} Maxdim {%- endif -%}
            {%- endif -%} {#- MaxDimStyle #}
   do StrPCopy({{ fvalue['arg'] }}^[{{ fvalue['arg'] }}_i-1],{{ fvalue['arg'] }}_s[{{ fvalue['arg'] }}_i]);
         {%- endif -%}
      {%- endfor -%} {#- ftpp -#}
      {%- if value['type'] == 'oss' %}
result := StrPCopy(sst_resultBuf, local_sst_result);
      {%- endif -%}
{%- if apidef.trace %}
writeln(' TRACE {{ value['name'] }} END (
{%- for fkey,fvalue in ftpp.iterrows() -%}
   {%- set delphiptr  = datadef.DelphiPtr.elements.loc[datadef.DelphiPtr.elements['ta']==fvalue['type']]   -%}
   {%- set delphigdx  = datadef.DelphiGDX.elements.loc[datadef.DelphiGDX.elements['ta']==fvalue['type']]   -%}
   {%- if fvalue['type'] == 'funcptr' -%}
      {%- set fm      = apidef.FuncMap.elements[apidef.FuncMap.elements['def'] == value['name']] -%}
      {%- for fmkey,fmvalue in fm[fm['fpos'].isin(tpp)].iterrows() if fm.shape[0] > 0 -%}
         {{ fvalue['arg'] }}: {{ fmvalue['name']}};
      {%- endfor %}
   {%- elif delphigdx.shape[0] > 0    -%}
      {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }};
   {%- else                           -%}
      {{ fvalue['arg'] }}=',
      {%- if delphiptr.shape[0] >0 -%} integer( {%- endif -%}
      {{ fvalue['arg'] }}
      {%- if delphiptr.shape[0] >0 -%} ) {%- endif -%}
      ,';
   {%- endif -%}
   {%- if not fvalue['type'] == 'void' or (fvalue['type'] in ['oss','funcptr']) -%} result=', {%- endif -%}
   {%- if delphiptr.shape[0] > 0 -%} integer( {%- endif -%}
   result
   {%- if delphiptr.shape[0] > 0 -%} )  {%- endif -%}
   ,';
{%- endfor -%}
)); flush(output);
{%- endif %}
end;
   {%- endfor -%} {#- apidef.tfunc #}
{%- endfor -%} {#- apidef.pre #}

{#- ***LW CF/BF not needed, only F client needs F functions and these use delphi versions of string functions, might be necessary to change later
-#} 

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set dobjectint = dobjectint(pre) -%}
   {%- set prefix     = prefix(pre)     -%}
   {%- set prexfix    = prexfix(pre)    -%}
   {%- set MaxDimStyle = '' -%}
   {%- if ((apidef.MaxDimStyle is defined) and (apidef.MaxDimStyle.elements.shape[0] > 0)) -%}
      {%- set mds = apidef.MaxDimStyle.elements[apidef.MaxDimStyle.elements['prefix']==pre] -%}
      {%- if mds.shape[0] > 0 -%}
          {%- set MaxDimStyle = mds['prefix'].iloc[0] -%}
      {%- endif -%}
   {%- endif -%}
   {%- set entmp = apidef.enp.elements[apidef.enp.elements['prefix']==pre]['element'].tolist()                      -%}
   {%- set enstrentmp = apidef.enostringa.elements[apidef.enostringa.elements['name'].isin(entmp)]['name'].tolist() -%}
   {%- for key,value in apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(enstrentmp)].iterrows() -%}
      {%- if value['type'] == 'void' %}

{{ functionsDescription(value['text']) }}
procedure
      {%- else                       %}

{{ functionsDescription(value['text']) }}
function
      {%- endif %} B{{ value['name'] }}(p{{ prefix }}: pointer
      {%- set tpp  = datadef.tpp.elements['tp']                                  -%}
      {%- set f    = apidef.f.elements[apidef.f.elements['name']==value['name']] -%}
      {%- set ftpp = f[f['pos'].isin(tpp)]                                       -%}
      {%- set counter = namespace(pos=1)                                         -%}
      {%- set fcounter = namespace(max=ftpp.shape[0])                            -%}
      {%- if ftpp.shape[0] > 0 -%}; {% endif -%}
      {%- for fkey,fvalue in ftpp.iterrows() -%}
         {%- set tass        = datadef.tass.elements.loc[datadef.tass.elements['ta']==fvalue['type']]               -%}
         {%- if tass.shape[0] > 0 -%}
            {{ DCallB(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DTypeB(fvalue['type']) }}
            {%- if fvalue['type'] == 'xss'-%}
               ; const {{ fvalue['arg'] }}_i: Integer
            {%-  endif -%}
         {%- else                 -%}
            {%- if fvalue['type'] == 'funcptr'           -%}
               {%- set fm      = apidef.FuncMap.elements[apidef.FuncMap.elements['def'] == value['name']] -%}
               {%- set fmcounter = namespace(pos=1)                                                       -%}
               {%- for fmkey,fmvalue in fm.iterrows() -%}
                  {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ fmvalue['name'] }}
                  {%- if fmcounter.pos < fm.shape[0]        -%}; {% endif -%}
                  {%- set fmcounter.pos = fmcounter.pos + 1 -%}
               {%- endfor -%}
            {%- elif fvalue['type'] in ['bool', 'vbool'] -%}
               {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: Integer
            {%- else                                     -%}
               {{ DCall(fvalue['type']) }}{{ fvalue['arg'] }}: {{ DType(fvalue['type']) }}
            {%-  endif -%}
         {%-  endif -%}
         {%- if counter.pos < fcounter.max -%}; {% endif -%}
         {%- set counter.pos = counter.pos + 1           -%}
      {%- endfor -%} {#- ftpp -#}
      {%- if value['type'] == 'oss' -%}; sst_resultBuf: pAnsiChar {%- endif -%}
)
      {%- if value['type'] != 'void'       -%}
         {%- if value['type'] == 'funcptr' -%}
            {%- for fmkey,fmvalue in apidef.FuncMap.elements[apidef.FuncMap.elements['def'].isin(entmp)].iterrows() -%}
               : {{ fmvalue['name'] }}
            {%- endfor -%}
         {%- elif value['type'] == 'bool'  -%} : Integer
         {%- elif value['type'] == 'oss'   -%} : pAnsiChar
         {%- else                          -%} : {{ DType(value['type']) }}
         {%- endif %}
      {%- endif -%}
; stdcall;
{%- if apidef.doc %}
// Arguments:
//   p{{ pre }}: Pointer to {{ pre.upper() }} structure
// Note: This is the VB wrapped version of <LINK {{ dobjectint }}.{{ value['name'] }}>
{%- endif %}
      {%- if value['type'] == 'oss' %}
var local_sst_result : shortstring;
      {%- endif %}
      {%- for fkey,fvalue in ftpp.iterrows() -%}
         {%- if fvalue['type'] in ['oss', 'xss']  %}
var local_{{ fvalue['arg'] }}: Shortstring;
         {%- elif fvalue['type'] in ['osi','csi']    %}
var {{ fvalue['arg'] }}_i, {{ fvalue['arg'] }}_j, {{ fvalue['arg'] }}_len : integer;
    {{ fvalue['arg'] }}_s : TgdxStrIndex;
         {%-  endif -%}
      {%- endfor -%} {#- ftpp -#}
      {%- set ftppvbool = ftpp[ftpp['type']=='vbool'] -%}
      {%- if ftppvbool.shape[0] > 0 %}
var
      {%- endif -%}
      {%- for fkey,fvalue in ftppvbool.iterrows() %}
   bb_{{ fvalue['arg'] }} : Boolean;
      {%- endfor -%} {#- ftpp #}
begin
{# newline -#}
      {%- for fkey,fvalue in ftpp[ftpp['name'].isin(entmp)].iterrows() if fvalue['type']=='funcptr' -%}
         {%- set PFtrF  = apidef.PFtrF.elements['name'].tolist()                                  -%}
         {%- set fm     = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==fvalue['name']] -%}
         {%- if PFtrF|length > 0 and fm.shape[0] > 0    -%}
            {%- set fmpos = fm[fm['fpos']==fvalue['pos']] -%}
            {%- if fmpos.shape[0] > 0 -%}
               {%- if fmpos[fmpos['name'].isin(PFtrF)].shape[0] > 0 %}
{{ dobjectint }}(p{{prefix }}).{{ fvalue['name'] }}_{{ fvalue['arg'] }}_CallByRef := false;
               {%- endif -%}
            {%- endif -%}
         {%- endif -%}
      {% endfor -%}
      {%- for fkey,fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
bb_{{ fvalue['arg'] }} := {{ fvalue['arg'] }} <> 0;
{# newline -#}
      {%- endfor -%} {#- ftpp -#}
      {%- for fkey,fvalue in ftpp[ftpp['type']=='csi'].iterrows() -%}
         {%- if ((apidef.callSymbolDim is defined) and (apidef.callSymbolDim.elements.shape[0] > 0)) -%}
            {%- set callsymboldim = apidef.callSymbolDim.elements[apidef.callSymbolDim.elements['name']==value['name']] -%}
            {%- if callsymboldim.shape[0] > 0 and fvalue['name'] in callsymboldim['name'].tolist() %}
for {{ fvalue['arg'] }}_i := 1 to {{ callSymbolDim['dimension'].iloc[0] }}
            {%- else                                                                               %}
for {{ fvalue['arg'] }}_i := 1 to {% if mds is defined and mds.shape[0] > 0 and 'gdx' in mds['prefix'].tolist() -%} TGXFileObj(p{{ prefix }}).GDXDimension{%- else -%} Maxdim {%- endif -%}
            {%- endif -%}
         {%- else                                                                                     %}
for {{ fvalue['arg'] }}_i := 1 to {% if mds is defined and mds.shape[0] > 0 and 'gdx' in mds['prefix'].tolist() -%} TGXFileObj(p{{ prefix }}).GDXDimension{%- else -%} Maxdim {%- endif -%}
         {%- endif %}
do {{ fvalue['arg'] }}_s[{{ fvalue['arg'] }}_i] := PCharToStr(pAnsiChar({{ fvalue['arg'] }}^[{{ fvalue['arg'] }}_i-1]));
{# newline -#}
      {%- endfor -%} {#- ftpp -#}
      {%- if value['type'] == 'oss'    %}
local_sst_{{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
      {%- endif -%}
      {%- if value['type'] != 'void'   %}
result := {{ dobjectint }}(p{{ prefix }}).{{ value['name'] }}
      {%- endif -%}
      {%- set farg = apidef.farg.elements.loc[apidef.farg.elements['name']==value['name']] -%}
      {%- if farg.shape[0] > 0 -%} (
         {%- set counter = namespace(ftpppos = 1) -%}
         {%- for fkey,fvalue in ftpp.iterrows() -%}
            {%- if fvalue['type'] == 'css'           -%} PCharToStr({{ fvalue['arg'] }})
            {%- elif fvalue['type'] in ['oss','xss'] -%} local_{{ fvalue['arg'] }}
            {%- elif fvalue['type'] in ['csi','osi'] -%} {{ fvalue['arg'] }}_s
            {%- elif fvalue['type'] == 'vbool'       -%} bb_{{ fvalue['arg'] }}_s
            {%- elif fvalue['type'] == 'bool'        -%} 0 <> {{ fvalue['arg'] }}
            {%- else                                 -%} {{ fvalue['arg'] }}
            {%- endif -%}
            {%- if counter.ftpppos < ftpp.shape[0] -%}, {% endif -%}
            {%- set counter.ftpppos = counter.ftpppos + 1        -%}
         {%- endfor -%} {#- ftpp -#}
)
         {%- if value['type'] == 'bool' -%} ) {%- endif -%}
      {%- endif -%}
;
      {%- for fkey,fvalue in ftpp[ftpp['type']=='vbool'].iterrows() %}
{{ fvalue['arg'] }} := Integer(bb_{{ fvalue['arg'] }});
      {%- endfor -%} {#- ftpp -#}
      {%- for fkey,fvalue in ftpp.iterrows() -%}
         {%- if fvalue['type'] == 'oss'    %}
StrPCopy({{ fvalue['arg'] }}, local_{{ fvalue['arg'] }});
         {%- elif fvalue['type'] == 'xss'  %}
StrPCopyN({{ fvalue['arg'] }}, local_{{ fvalue['arg'] }}, {{ fvalue['arg'] }}_i);
         {%- elif fvalue['type'] == 'osi' -%}
            {%- if MaxDimStyle == 'gdx' %}
if result <> 0
then
            {%- endif -%} {#- MaxDimStyle -#}
            {%- if ((apidef.callSymbolDim is defined) and (apidef.callSymbolDim.elements.shape[0] > 0)) -%}
               {%- set callsymboldim = apidef.callSymbolDim.elements[apidef.callSymbolDim.elements['name']==value['name']] -%}
               {%- if callsymboldim.shape[0] > 0 and fvalue['name'] in callsymboldim['name'].tolist() %}
   for {{ fvalue['arg'] }}_i := 1 to {{ callsymboldim['dimension'].iloc[0] }}
               {%- else                                                                               %}
   for {{ fvalue['arg'] }}_i := 1 to {% if mds is defined and mds.shape[0] > 0 and 'gdx' in mds['prefix'].tolist() -%} TGXFileObj(p{{ prefix }}).GDXDimension{%- else -%} Maxdim {%- endif -%}
               {%- endif -%}
            {%- else                                                                                     %}
   for {{ fvalue['arg'] }}_i := 1 to {% if mds is defined and mds.shape[0] > 0 and 'gdx' in mds['prefix'].tolist() -%} TGXFileObj(p{{ prefix }}).GDXDimension{%- else -%} Maxdim {%- endif -%}
            {%- endif %}
   do begin
      {{ fvalue['arg'] }}_len := integer({{ fvalue['arg'] }}_s[{{ fvalue['arg'] }}_i][0]);
      for {{ fvalue['arg'] }}_j := 1 to {{ fvalue['arg'] }}_len
      do {{ fvalue['arg'] }}[{{ fvalue['arg'] }}_i][{{ fvalue['arg'] }}_j-1] := {{ fvalue['arg'] }}_s[{{ fvalue['arg'] }}_i][{{ fvalue['arg'] }}_j];
      end;
         {%- endif -%}
      {%- endfor -%} {#- ftpp -#}
      {%- if value['type'] == 'oss' %}
result := StrPCopy(sst_resultBuf, local_sst_result);
      {%- endif %}
end;
   {%- endfor -%} {#- apidef.tfunc #}
{%- endfor -%} {#- apidef.pre #}

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set dobjectint = dobjectint(pre) -%}
   {%- set prefix     = prefix(pre)     -%}
   {%- set entmp = apidef.enp.elements[apidef.enp.elements['prefix']==pre]['element'].tolist()    -%}
   {%- set tprop = apidef.tprop.elements[apidef.tprop.elements['name'].isin(entmp)]               -%}
   {%- for key,value in tprop.iterrows() -%}
      {%- for pkey, pvalue in apidef.pn.elements[apidef.pn.elements['name']==value['name']].iterrows() -%}
         {%- set delphiptr = datadef.DelphiPtr.elements.loc[datadef.DelphiPtr.elements['ta']==pvalue['type']]   -%}
         {%- set datatype  = datadef.DelphiType.elements.loc[datadef.DelphiType.elements['ta']==pvalue['type']] -%}
         {%- if pvalue['pactions']=='r' %}
            {%- if pvalue['type'] != 'funcptr' %}
               {%- if pvalue['type'] == 'oss'    %}

procedure {{ pvalue['name'] }}(p{{ prefix }}: pointer; var sst_result: ShortString); stdcall;
               {%- elif pvalue['type'] == 'bool' %}

function  {{ pvalue['name'] }}(p{{ prefix }}: pointer): Integer; stdcall;
               {%- else                          %}

function  {{ pvalue['name'] }}(p{{ prefix }}: pointer): {{ datatype['text'].iloc[0] }}; stdcall;
               {%- endif %}
{%- if apidef.doc %}
// Arguments:
//   p{{ prefix }}: Pointer to {{ pre.upper() }} structure
// Note: This is the Delphi wrapped version of <LINK {{ dobjectint }}.{{ pvalue['name'] }}>
{%- endif %}
begin
{%- if apidef.trace %}
writeln(' TRACE {{ pvalue['name'] }} BEG'); flush(output);
{%- endif %}
               {%- if pvalue['type'] == 'oss'    %}
sst_result := {{ dobjectint }}(p{{ prefix }}).{{ pvalue['name'] }};
{%- if apidef.trace %}
writeln(' TRACE {{ pvalue['name'] }} END result=', sst_result); flush(output);
{%- endif %}
               {%- elif pvalue['type'] == 'bool' %}
result := Integer({{ dobjectint }}(p{{ prefix }}).{{ pvalue['name'] }});
{%- if apidef.trace %}
writeln(' TRACE {{ pvalue['name'] }} END result=', result); flush(output);
{%- endif %}
               {%- else                         %}
result := {{ dobjectint }}(p{{ prefix }}).{{ pvalue['name'] }};
               {%- endif %}
{%- if apidef.trace %}
   {%- if delphiptr.shape[0] > 0  %}
writeln(' TRACE {{ pvalue['name'] }} END result=', integer(result)); flush(output);
   {%- else                       %}
writeln(' TRACE {{ pvalue['name'] }} END result=', result); flush(output);
   {%- endif %}
{%- endif %}
            {%- else                         %}
               {%- set fm = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
               {%- for fmkey,fmvalue in fm[fm['fpos']=='p'].iterrows() if fm.shape[0] > 0 -%}

function  {{ pvalue['name'] }}(p{{ prefix }}: pointer): {{ fmvalue['name'] }}; stdcall;
               {%- endfor %}
{%- if apidef.doc %}
// Arguments:
//   p{{ prefix }}: Pointer to {{ pre.upper() }} structure
// Note: This is the Delphi wrapped version of <LINK {{ dobjectint }}.{{ pvalue['name'] }}>
{%- endif %}
begin
result := {{ fmvalue['name'] }}({{ dobjectint }}(p{{ prefix }}).{{ pvalue['name'] }});
            {%- endif %}
end;
         {%- else                       %}
            {%- if pvalue['type']=='funcptr' %}
               {%- set fm = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
               {%- for fmkey,fmvalue in fm[fm['fpos']=='p'].iterrows() if fm.shape[0] > 0 %}

procedure {{ pvalue['name'] }}Set(p{{ prefix }}: pointer; const x: {{ fmvalue['name'] }}); stdcall;
               {%- endfor %}
            {%- elif pvalue['type']=='bool'  %}

procedure {{ pvalue['name'] }}Set(p{{ prefix }}: pointer; const x: Integer); stdcall;
            {%- else                         %}

procedure {{ pvalue['name'] }}Set(p{{ prefix }}: pointer; const x: {{ datatype['text'].iloc[0] }}); stdcall;
            {%- endif %}
{%- if apidef.doc %}
// Arguments:
//   p{{ prefix }}: Pointer to {{ pre.upper() }} structure
// Note: This is the Delphi wrapped version of <LINK {{ dobjectint }}.{{ pvalue['name'] }}>
{%- endif %}
begin
{%- if apidef.trace %}
   {%- if pvalue['type']=='funcptr' %}
      {%- set fm = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- for fmkey,fmvalue in fm[fm['fpos']=='p'].iterrows() if fm.shape[0] > 0 -%}
writeln(' TRACE {{ pvalue['name'] }} END result: {{ fmvalue['name'] }}'); flush(output);
      {%- endfor %}
   {%- elif delphiptr.shape[0] > 0 %}
writeln(' TRACE {{ pvalue['name'] }}Set BEG x=',integer(x)); flush(output);
   {%- else                        %}
writeln(' TRACE {{ pvalue['name'] }}Set BEG x=',x); flush(output);
   {%- endif %}
{%- endif %}
            {%- if pvalue['type']=='bool' %}
{{ dobjectint }}(p{{ prefix }}).{{ pvalue['name'] }} := x <> 0;
            {%- else                      %}
{{ dobjectint }}(p{{ prefix }}).{{ pvalue['name'] }} := x;
            {%- endif %}
{%- if apidef.trace %}
writeln(' TRACE {{ pvalue['name'] }}Set END'); flush(output);
{%- endif %}
end;
         {%- endif %}
      {%- endfor -%} {#- apidef.pn #}
   {%- endfor -%} {#- tprop #}
{%- endfor -%} {#- apidef.pre #}

{%- if apidef.tprop.elements.shape[0] > 0 %}
   {%- set tprop   = apidef.tprop.elements[apidef.tprop.elements['type'] == 'oss'] -%}
   {%- if tprop.shape[0] > 0 %}

{ --- Entry points having string arguments }
   {%- endif %}
{%- endif %}

{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set dobjectint = dobjectint(pre) -%}
   {%- set prefix     = prefix(pre)     -%}
   {%- set entmp = apidef.enp.elements[apidef.enp.elements['prefix']==pre]['element'].tolist()    -%}
   {%- set tprop = apidef.tprop.elements[apidef.tprop.elements['name'].isin(entmp)]               -%}
   {%- for key,value in tprop.iterrows() if value['type'] == 'oss' -%}
      {%- for pkey, pvalue in apidef.pn.elements[apidef.pn.elements['name']==value['name']].iterrows() -%}
         {%- if pvalue['pactions']=='r' %}

function  C{{ pvalue['name'] }}(p{{ prefix }}: pointer; sst_resultBuf: pAnsiChar): pAnsiChar; stdcall;
            {%- if apidef.doc %}
// Arguments:
//   p{{ pre }}: Pointer to {{ pre.upper() }} structure
// Note: This is the Delphi wrapped version of <LINK {{ dobjectint }}.{{ value['name'] }}>
            {%- endif %}
var local_buf: Shortstring;
begin
            {%- if apidef.trace %}
writeln(' TRACE C{{ pvalue['name'] }} BEG'); flush(output);
            {%- endif %}
local_buf := {{ dobjectint }}(p{{ prefix }}).{{ pvalue['name'] }};
            {%- if apidef.trace %}
writeln(' TRACE C{{ pvalue['name'] }} END result=',local_buf); flush(output);
            {%- endif %}
result := StrPCopy(sst_resultBuf, local_buf);
end;
         {%- else                       %}

procedure C{{ pvalue['name'] }}Set(p{{ prefix }}: pointer; const x: pAnsiChar); stdcall;
            {%- if apidef.doc %}
// Arguments:
//   p{{ pre }}: Pointer to {{ pre.upper() }} structure
// Note: This is the Delphi wrapped version of <LINK {{ dobjectint }}.{{ value['name'] }}>
            {%- endif %}
begin
            {%- if apidef.trace %}
writeln(' TRACE C{{ pvalue['name'] }} BEG x=',PCharToStr(x)); flush(output);
            {%- endif %}
{{ dobjectint }}(p{{ prefix }}).{{ pvalue['name'] }} := PCharToStr(x);
            {%- if apidef.trace %}
writeln(' TRACE C{{ pvalue['name'] }} END'); flush(output);
            {%- endif %}
end;
         {%- endif %}
      {%- endfor -%} {#- apidef.pn #}
   {%- endfor -%} {#- tprop #}
{%- endfor -%} {#- apidef.pre #}

exports
{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set prefix  = prefix(pre)  -%}
   {%- set prexfix = prexfix(pre) -%}
   {%- set usecd = false -%}
   {%- if apidef.UseCD.elements.shape[0] > 0 -%}
     {%- if apidef.UseCD.elements[apidef.UseCD.elements['prefix']==pre].shape[0] > 0 -%}
         {%- set usecd = true -%}
     {%- endif -%}
   {%- endif %}
   {{ prexfix }}Create name '{{ prexfix.lower() }}create',
   {%- if usecd %}
   {{ prexfix }}CreateD name '{{ prexfix.lower() }}created',
   C{{ prexfix }}CreateD name 'c{{ prexfix.lower() }}created',
   {%- endif %}
   {{ prexfix }}Free name '{{ prexfix.lower() }}free',
   {{ prefix  }}Create name '{{ prefix.lower() }}create',
   {%- if usecd %}
   {{ prefix }}CreateD name '{{ prefix.lower() }}created',
   C{{ prefix }}CreateD name 'c{{ prefix.lower() }}created',
   {%- endif %}
   {{ prefix }}Free name '{{ prefix.lower() }}free',
   {{ prexfix }}APIVersion name '{{ prexfix.lower() }}apiversion',
  C{{ prexfix }}APIVersion name 'c{{ prexfix.lower() }}apiversion',
   {{ prexfix }}Check name '{{ prexfix.lower() }}check',
  C{{ prexfix }}Check name 'c{{ prexfix.lower() }}check',
   {%- if not apidef.multi  %}
   {{ prefix }}{{ prexfix }}Create name '{{ prefix.lower() }}{{ prexfix.lower() }}create',
      {%- if usecd %}
   {{ prefix }}{{ prexfix }}CreateD name '{{ prefix.lower() }}{{ prexfix.lower() }}created',
   C{{ prefix }}{{ prexfix }}CreateD name 'c{{ prefix.lower() }}{{ prexfix.lower() }}created',
      {%- endif %}
   {{ prefix }}{{ prexfix }}Free name '{{ prefix.lower() }}{{ prexfix.lower() }}free',
   {{ prefix }}{{ prexfix }}APIVersion name '{{ prefix.lower() }}{{ prexfix.lower() }}apiversion',
   {{ prefix }}{{ prexfix }}Check name '{{ prefix.lower() }}{{ prexfix.lower() }}check',
   {%- endif -%}
   {%- if apidef.ulp.elements.shape[0] > 0 %}
      {%- set ulp = apidef.ulp.elements[apidef.ulp.elements['prefix'] == pre] -%}
      {%- if ulp.shape[0] > 0  %}
   {{ prefix }}SetLoadPath name '{{ prefix.lower() }}setloadpath',
  C{{ prefix }}SetLoadPath name 'c{{ prefix.lower() }}setloadpath',
   {{ prefix }}GetLoadPath name '{{ prefix.lower() }}getloadpath',
  C{{ prefix }}GetLoadPath name 'c{{ prefix.lower() }}getloadpath',
      {%- endif %}
   {%- endif -%}
{% endfor %}

{%- set first = namespace(value=true) -%}
{%- for key,value in apidef.tfunc.elements.iterrows() %}
{%- if not first.value -%} , {%- endif %}
   {{ value['name'] }} name '{{ value['name'].lower() }}'
{%- set first.value = false -%}
{%- endfor %}

{%- if apidef.fpf.elements.shape[0] > 0 -%}
   {%- set fpf   = apidef.fpf.elements['def'].tolist()                            -%}
   {%- for key,value in apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(fpf)].iterrows() -%}
      {%- set PFtrF  = apidef.PFtrF.elements['name'].tolist()                                 -%}
      {%- set fm     = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- if PFtrF|length > 0 and fm.shape[0] > 0 and fm[fm['name'].isin(PFtrF)].shape[0] > 0 %},
  F{{ value['name'] }} name 'f{{ value['name'].lower() }}'
      {%- endif %}
   {%- endfor %}
{%- endif %}

{%- set tfenstring = apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(enstring)] -%}
{%- for key,value in tfenstring.iterrows() %},
  C{{ value['name'] }} name 'c{{ value['name'].lower() }}'
{%- endfor %}

{%- set enostringa   = apidef.enostringa.elements['name'].tolist()                           -%}
{%- set tfenostringa = apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(enostringa)] -%}
{%- for key,value in tfenostringa.iterrows() %},
  B{{ value['name'] }} name 'b{{ value['name'].lower() }}'
{%- endfor %}

{%- for key,value in apidef.pn.elements.iterrows() %}
{%- if value['pactions'] == 'r' -%} ,
   {{ value['name'] }} name '{{ value['name'].lower() }}'
{%- else                        -%} ,
   {{ value['name'] }}Set name '{{ value['name'].lower() }}set'
{%- endif -%}
{%- endfor %}

{%- for key,value in apidef.pn.elements.iterrows() if value['type'] == 'oss' %}
{%- if value['pactions'] == 'r' -%} ,
  C{{ value['name'] }} name 'c{{ value['name'].lower() }}'
{%- else                        -%} ,
  C{{ value['name'] }}Set name 'c{{ value['name'].lower() }}set'
{%- endif -%}
{%- endfor -%}
,
{%- for pre in apidef.pre.elements['prefix'].tolist() -%}
   {%- set prefix  = prefix(pre)   -%}
   {%- set prexfix = prexfix(pre ) -%}
   {%- set usecd = false -%}
   {%- if apidef.UseCD.elements.shape[0] > 0 -%}
     {%- if apidef.UseCD.elements[apidef.UseCD.elements['prefix']==pre].shape[0] > 0 -%}
         {%- set usecd = true -%}
     {%- endif -%}
   {%- endif %}
   {{ prexfix }}Create name '{{ prexfix.lower() }}create_',
   {%- if usecd %}
   {{ prexfix }}CreateD name '{{ prexfix.lower() }}created_',
  C{{ prexfix }}CreateD name 'c{{ prexfix.lower() }}created_',
   {%- endif %}
   {{ prexfix }}Free name '{{ prexfix.lower() }}free_',
   {{ prefix }}Create name '{{ prefix.lower() }}create_',
   {%- if usecd %}
   {{ prefix }}CreateD name '{{ prefix.lower() }}created_',
  C{{ prefix }}CreateD name 'c{{ prefix.lower() }}created_',
   {%- endif %}
   {{ prefix }}Free name '{{ prefix.lower() }}free_',
   {{ prexfix }}APIVersion name '{{ prexfix.lower() }}apiversion_',
  C{{ prexfix }}APIVersion name 'c{{ prexfix.lower() }}apiversion_',
   {{ prexfix }}Check name '{{ prexfix.lower() }}check_',
  C{{ prexfix }}Check name 'c{{ prexfix.lower() }}check_',
   {%- if not apidef.multi  %}
   {{ prefix }}{{ prexfix }}Create name '{{ prefix.lower() }}{{ prexfix.lower() }}create_',
      {%- if usecd %}
   {{ prefix }}{{ prexfix }}CreateD name '{{ prefix.lower() }}{{ prexfix.lower() }}created_',
  C{{ prefix }}{{ prexfix }}CreateD name 'c{{ prefix.lower() }}{{ prexfix.lower() }}created_',
      {%- endif %}
   {{ prefix }}{{ prexfix }}Free name '{{ prefix.lower() }}{{ prexfix.lower() }}free_',
   {{ prefix }}{{ prexfix }}APIVersion name '{{ prefix.lower() }}{{ prexfix.lower() }}apiversion_',
   {{ prefix }}{{ prexfix }}Check name '{{ prefix.lower() }}{{ prexfix.lower() }}check_',
   {%- endif %}
   {%- if apidef.ulp.elements.shape[0] > 0 %}
      {%- set ulp = apidef.ulp.elements[apidef.ulp.elements['prefix'] == pre] -%}
      {%- if ulp.shape[0] > 0  %}
   {{ prefix }}SetLoadPath name '{{ prefix.lower() }}setloadpath_',
  C{{ prefix }}SetLoadPath name 'c{{ prefix.lower() }}setloadpath_',
   {{ prefix }}GetLoadPath name '{{ prefix.lower() }}getloadpath_',
  C{{ prefix }}GetLoadPath name 'c{{ prefix.lower() }}getloadpath_',
      {%- endif -%}
   {%- endif -%}
{% endfor %}

{%- set ffirst = namespace(value=true) -%}
{%- for key,value in apidef.tfunc.elements.iterrows() %}
{%- if not ffirst.value -%} , {%- endif %}
   {{ value['name'] }} name '{{ value['name'].lower() }}_'
{%- set ffirst.value = false -%}
{%- endfor %}

{%- if apidef.fpf.elements.shape[0] > 0 -%}
   {%- for key,value in apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(fpf)].iterrows() -%}
      {%- set PFtrF  = apidef.PFtrF.elements['name'].tolist()                                 -%}
      {%- set fm     = apidef.FuncMap.elements[apidef.FuncMap.elements['def']==value['name']] -%}
      {%- if PFtrF|length > 0 and fm.shape[0] > 0 and fm[fm['name'].isin(PFtrF)].shape[0] > 0 %},
  F{{ value['name'] }} name 'f{{ value['name'].lower() }}_'
      {%- endif %}
   {%- endfor %}
{%- endif %}

{%- set tfenstring = apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(enstring)] -%}
{%- for key,value in tfenstring.iterrows() %},
  C{{ value['name'] }} name 'c{{ value['name'].lower() }}_'
{%- endfor %}

{%- set enostringa   = apidef.enostringa.elements['name'].tolist()                           -%}
{%- set tfenostringa = apidef.tfunc.elements[apidef.tfunc.elements['name'].isin(enostringa)] -%}
{%- for key,value in tfenostringa.iterrows() %},
  B{{ value['name'] }} name 'b{{ value['name'].lower() }}_'
{%- endfor %}

{%- for key,value in apidef.pn.elements.iterrows() %}
    {%- if value['pactions'] == 'r' -%} ,
   {{ value['name'] }} name '{{ value['name'].lower() }}_'
    {%- else                        -%} ,
   {{ value['name'] }}Set name '{{ value['name'].lower() }}set_'
   {%- endif -%}
{%- endfor %}

{%- for key,value in apidef.pn.elements.iterrows() if value['type'] == 'oss' %}
   {%- if value['pactions'] == 'r' %},
  C{{ value['name'] }} name 'c{{ value['name'].lower() }}_'
   {%- else                        %},
  C{{ value['name'] }}Set name 'c{{ value['name'].lower() }}set_'
   {%- endif -%}
{%- endfor -%}
;

begin
end.
{% endblock %}